<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Book on Today I Learn</title>
    <link>https://92SooJong.github.io/tags/book/</link>
    <description>Recent content in Book on Today I Learn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Oct 2022 22:55:00 +0900</lastBuildDate><atom:link href="https://92SooJong.github.io/tags/book/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Chapter2. Overview of the JVM</title>
      <link>https://92SooJong.github.io/posts/java/java-optimizing/chapter2-overview-of-the-jvm/</link>
      <pubDate>Sun, 30 Oct 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/java/java-optimizing/chapter2-overview-of-the-jvm/</guid>
      <description>Interpreting and Classloading JVM은 stack-based interpreted machine이다. 이 뜻은 CPU같은 물리적 하드웨어를 뜻하는게 아니라 execution stack을 의미한다. 그리고 이 스택에 존재하는 값들을 통해서 계산을 수행한다.
예를들어 java HelloWorld 커맨드를 실행하면, 운영체제는 virtual machine process(the java binary)를 실행한다. 이 과정에서 자바 가상 환경 세팅과 초기화를 수행한다. 이 결과로 HelloWorld.class 파일을 생성한다.
생성된 클래스 파일의 진입점은 main() 메소드가 될것이다. 클래스 파일을 제어하기 위해선 가상 머신을 실행하기 전에 클래스 파일이 로딩되어야한다.
이 작업을 위해 Java Class Loading 메커니즘이 사용된다.</description>
    </item>
    
    <item>
      <title>Generic</title>
      <link>https://92SooJong.github.io/posts/java/java-standard/generic/</link>
      <pubDate>Thu, 29 Sep 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/java/java-standard/generic/</guid>
      <description>제네릭의 기본인 1.1~1.3은 생략함
1.4 제한된 지네릭 클래스 다음과 같이 작성하면 Fruit의 자손타입만 T에 대입할 수 있다. (= Fruit를 implements 또는 extends한 클래스만 T에 대입할 수 있다.) 좀 더 엄격하게 FruitBox에 들어올 수 있는 타입을 관리할 수 있다.
1class FruitBox&amp;lt;T extends Fruit&amp;gt;{ 2	ArrayList&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;T&amp;gt;(); 3	... 4} Fruit의 자손 인스턴스는 얼마든지 담을 수 있다. 다형성을 이용해 여러 과일을 담을 수 있게 되었다.
1FruitBox&amp;lt;Fruit&amp;gt; fruitBox = new FruitBox&amp;lt;Fruit&amp;gt;(); 2fruitBox.</description>
    </item>
    
    <item>
      <title>7.3 복합 키와 식별 관계 매핑</title>
      <link>https://92SooJong.github.io/posts/jpa/book-1/7-3-%EB%B3%B5%ED%95%A9-%ED%82%A4%EC%99%80-%EC%8B%9D%EB%B3%84-%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</link>
      <pubDate>Tue, 02 Aug 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/jpa/book-1/7-3-%EB%B3%B5%ED%95%A9-%ED%82%A4%EC%99%80-%EC%8B%9D%EB%B3%84-%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</guid>
      <description>7.3 복합 키와 식별 관계 매핑 7.3.1 식별 관계 vs 비식별 관계 식별관계 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용한다. 비식별 관계 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다. 필수적 비식별 관계(Mandatory) 외래 키에 NULL을 허용하지 않는다. 반드시 연관관계를 맺어야 한다. 선택적 비식별 관계(Optional) 외래 키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다. 최근 트렌드는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다.</description>
    </item>
    
    <item>
      <title>7.2 @MappedSuperClass</title>
      <link>https://92SooJong.github.io/posts/jpa/book-1/7-2-mappedsuperclass/</link>
      <pubDate>Mon, 01 Aug 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/jpa/book-1/7-2-mappedsuperclass/</guid>
      <description>7.2 @MappedSuperClass 7.1에서 본 전략은 부모 클래스가 실제 물리 테이블과 매핑되어 있어야 한다. @MappedSuperClass 를 사용하면 부모 클래스는 물리 테이블과 매핑하지 않고 부모 클래스를 상속받은 자식만 물리 테이블로 생성할 수 있다. 2개의 자식 클래스가 BaseEntity를 상속받는다. 물리테이블은 아래와 같이 2개만 생성된다. </description>
    </item>
    
    <item>
      <title>7.1 상속 관계 매핑</title>
      <link>https://92SooJong.github.io/posts/jpa/book-1/7-1-%EC%83%81%EC%86%8D-%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</link>
      <pubDate>Sun, 31 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/jpa/book-1/7-1-%EC%83%81%EC%86%8D-%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/</guid>
      <description>7.1 상속 관계 매핑 조인 전략 슈퍼타입 역할을 할 엔티티를 만든다. @Inheritance 어노테이션을 통해서 매핑전략을 지정할 수 있다. 현재 예시에선 조인 전략을 사용하므로 InheritanceType.JOINED 로 전략을 지정한다. @DiscriminatorColumn 어노테이션을 통해서 자식 엔티티를 구분하기 위한 컬럼을 생성한다. 자식 엔티티는 부모 엔티티인 Item을 상속한다. @DiscriminatorValue 어노테이션을 통해 엔터티 구분을 위한 코드를 지정한다. @PrimaryKeyJoinColumn 어노테이션을 통해 부모 엔터티에서 제공하는 PK명을 수정할 수 있다. 물리테이블과 컬럼은 아래와 같이 생성된다. 장점 테이블 정규화 외래 키 참조 무결성 제약조건 활용 가능 저장공간의 효율성 단점 조회시 Join을 사용하므로 성능 저하 발생가능성이 높아짐 조회 쿼리가 복잡하다.</description>
    </item>
    
    <item>
      <title>4.3 도커 컴포즈 사용</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/4-3-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EC%82%AC%EC%9A%A9/</link>
      <pubDate>Fri, 29 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/4-3-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EC%82%AC%EC%9A%A9/</guid>
      <description>4.3.1 도커 컴포즈 기본 사용법 도커 컴포즈는 컨테이너의 설정이 정의된 YAML 파일을 읽어서 컨테이너를 생성한다. 아래와 같이 docker-compose.yml 파일을 작성한다. version 은 YAML파일의 포맷버전을 의미한다. services 생성될 컨테이너를 묶는 단위를 의미한다. web mysql 생성될 서비스의 이름이다. 해당 항목 아래에 컨테이너가 생성될 때 필요한 옵션을 지정할 수 있다. 1version: &amp;#39;3.0&amp;#39; 2services: 3 web: 4 image: alicek106/composetest:web 5 ports: 6 - &amp;#34;80:80&amp;#34; 7 links: 8 - mysql:db 9 command: sh -c &amp;#39;echo &amp;#34;ServerName localhost&amp;#34; &amp;gt;&amp;gt; /etc/apache2/apache2.</description>
    </item>
    
    <item>
      <title>4.2 도커 컴포즈 설치</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/4-2-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EC%84%A4%EC%B9%98/</link>
      <pubDate>Thu, 28 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/4-2-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EC%84%A4%EC%B9%98/</guid>
      <description>0.도커 컴포즈를 사용하는 이유 여러 개의 컨테이너가 하나의 애플리케이션으로 동작할때 컨테이너를 한번에 생성해야한다. 여러 개의 컨테이너를 하나의 서비스로 정의해 컨테이너 묶음으로 관리할 수있도록 한다. 1. 설치 현재 ubuntu 계정이 sudo 없이 docker에 접근할 수 있도록 설정한다. 1sudo usermod -aG docker ${USER} 2sudo su - 3su - ubuntu 4groups ubuntu 아래 명령어를 통해 도커 컴포즈 1.1 버전을 다운로드 받는다. 1sudo curl -L https://github.com/docker/compose/releases/download/1.11.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose docker-compose -v 명령어를 통해서 정상적으로 설치되었는지 확인한다.</description>
    </item>
    
    <item>
      <title>3.3 스웜모드</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-3-%EC%8A%A4%EC%9B%9C%EB%AA%A8%EB%93%9C/</link>
      <pubDate>Wed, 27 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-3-%EC%8A%A4%EC%9B%9C%EB%AA%A8%EB%93%9C/</guid>
      <description>docker info 명령어를 통해 도커 엔진의 스웜 모드 클러스터 정보를 확인한다. 1sudo docker info | grep Swarm 현재는 스웜 모드를 사용하지 않기 때문에 비활성화 상태이다. 3.3.2 도커 스웜 모드 클러스터 구축 아래와 같이 3개의 ubuntu 인스턴스를 만든다. docker swarm init 명령어를 통해 클러스터의 매니저를 지정한다. 1sudo docker swarm init --advertise-addr [매니저노드 IP] 워커 노드들은 매니저를 지정할때 출력되는 명령어를 통해 클러스터에 등록할 수 있다. 매니저 노드를 지정할때 제공되는 docker swarm join 명령어를 통해서 워커노드가 특정 클러스터에 합류할 수 있다.</description>
    </item>
    
    <item>
      <title>16.1 트랜잭션과 락</title>
      <link>https://92SooJong.github.io/posts/jpa/book-1/16-1-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EB%9D%BD/</link>
      <pubDate>Tue, 26 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/jpa/book-1/16-1-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EB%9D%BD/</guid>
      <description>16.1 트랜잭션과 락 16.1.1 트랜잭션과 격리 수준 트랜잭션은 기본적으로 ACID중 원자성, 일관성, 지속성은 만족한다. 여기서 다루기 피곤한 녀석이 격리성이다. 단순히 트랜잭션 간에 간섭이 없도록 격리성을 분리해버리면 테이블 접근이 제한적이기때문에 동시성 처리 성능이 떨어지게된다.
격리수준(Isolation Level) 동시성 처리를 위해서 대부분의 Database는 READ COMMITED를 기본으로한다
READ UNCOMMITTED 커밋하지 않은 데이터를 읽을 수 있다. 트랜잭션1이 데이터를 변경하는 로직을 수행하더라도 트랜잭션2는 데이터를 읽을수 있다. 이를 DIRTY READ라 한다. READ COMMITED 커밋한 데이터만 읽을 수 있다.</description>
    </item>
    
    <item>
      <title>3.2 스웜 클래식과 도커 스웜 모드</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-2-%EC%8A%A4%EC%9B%9C-%ED%81%B4%EB%9E%98%EC%8B%9D%EA%B3%BC-%EB%8F%84%EC%BB%A4-%EC%8A%A4%EC%9B%9C-%EB%AA%A8%EB%93%9C/</link>
      <pubDate>Tue, 26 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-2-%EC%8A%A4%EC%9B%9C-%ED%81%B4%EB%9E%98%EC%8B%9D%EA%B3%BC-%EB%8F%84%EC%BB%A4-%EC%8A%A4%EC%9B%9C-%EB%AA%A8%EB%93%9C/</guid>
      <description>스웜 클래식과 스웜 모드는 여러 대의 도커 서버를 하나의 클러스터로 만들어 컨테이너를 생성하는 여러 기능을 제공한다. 개발자는 다양한 전략을 세워 컨테이너를 특정 도커 서버에 할당 할수 있도록 할 수 있다. 스웜 클러스터에 등록된 서버를 손쉽게 관리할 수 있다. 도커 스웜 모드가 실제 운영 환경에서 많이 쓰이진 않는다. 도커 스웜의 종류 컨테이너로서의 스웜 도커 1.6 버전부터 사용 가능 스웜 클래식이라고도 부름 스웜 클래식은 여러 대의 도커 서버를 하나의 지점에서 사용하도록 단일 접근점을 제공하는 방식이다.</description>
    </item>
    
    <item>
      <title>3.1 도커 스웜을 사용하는 이유</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-1-%EB%8F%84%EC%BB%A4-%EC%8A%A4%EC%9B%9C%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/</link>
      <pubDate>Mon, 25 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-1-%EB%8F%84%EC%BB%A4-%EC%8A%A4%EC%9B%9C%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/</guid>
      <description> 도커를 적용하기 위한 여러 대의 서버를 하나의 자원 풀로 만들기 위해 등장했다. 새로운 서버나 컨테이너가 추가됐을때 이를 발견(Service Discovery)하는 작업을 수행한다. 어떤 서버에 컨테이너를 할당 할것인가 하는 스케줄러 및 로드밸런서 역할을 수행한다. 클러스터 내의 서버가 다운됐을 때 고가용성(High Availability)을 보장해준다. docker swam과 swam mode는 도커에서 공식적으로 제공한다. </description>
    </item>
    
    <item>
      <title>2.4 Dockerfile</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-4-dockerfile/</link>
      <pubDate>Sun, 24 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-4-dockerfile/</guid>
      <description>2.4 Dockerfile 새로운 이미지를 생성하기 위해 사용하는 일련의 명령어를 실행할 수 있도록 해주는 파일 컨테이너에서 수행해야 할 작업을 명시하고 이미지를 생성한다. 2.4.2 Dockerfile 작성 샘플 파일을 생성한다. Dockerfile을 작성한다. FROM 은 생성할 이미지의 베이스가 될 이미지를 뜻한다. Dockerfile에 반드시 한 번 이상 입력해야한다. MAINTAINER 은 이미지를 생성한 개발자의 정보를 나타낸다. LABEL 은 이미지의 메타데이터를 뜻한다. RUN 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행한다. RUN [&amp;quot;실행가능한 파일&amp;quot;,&amp;quot;명령줄 인자1&amp;quot;,&amp;quot;명령줄 인자 2, ... ] 형태로 작성가능하다.</description>
    </item>
    
    <item>
      <title>2.3 도커 이미지</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-3-%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80/</link>
      <pubDate>Sat, 23 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-3-%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80/</guid>
      <description>2.3 도커 이미지 이미지 검색 도커는 Docker Hub라는 중앙 이미지 저장소에서 이미지를 내려받는다. search 명령어를 통해 도커 이미지를 검색할 수 있습니다. 이미지 생성 샘플 컨테이너를 생성하고 커스터마이징 해본다. 1sudo docker run -i -t --name commit_test ubuntu:14.04 commit 명령어를 통해서 컨테이너를 이미지로 만들수 있다. -a 옵션은 author를 뜻한다. -m 은 커밋 메시지를 뜻한다. commit_test 컨테이너를 이름은 commit_test이고 태그가 first인 이미지로 생성한다. 1sudo docker commit \ 2-a &amp;#34;soojong&amp;#34; -m &amp;#34;my first commit&amp;#34; \ 3commit_test \ 4commit_test:first 한단계 더 나아가서 commit_test 이미지로 또다른 이미지를 만들어 보자.</description>
    </item>
    
    <item>
      <title>2.2 도커 컨테이너 다루기</title>
      <link>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-2-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EB%8B%A4%EB%A3%A8%EA%B8%B0/</link>
      <pubDate>Fri, 22 Jul 2022 22:55:00 +0900</pubDate>
      
      <guid>https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-2-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EB%8B%A4%EB%A3%A8%EA%B8%B0/</guid>
      <description>2.2 도커 컨테이너 다루기 컨테이너 실행해보기 run 명령어를 사용해서 우분투 14.04 컨테이너 실행하기
1docker run -i -t ubuntu:14.04 로컬에 설치된 이미지가 없기 때문에 내려받아서 컨테이너를 실행 시켜줌.
사용자 이름을 보면 알 수 있듯이 컨테이너 내부에 들어온것을 볼수 있다.
-i 옵션으로 상호 입출력을 가능하게 한다.
-t 옵션으로 tty를 활성화 해서 bash shell을 사용할 수 있도록 한다.
두 옵션이 없으면 shell을 정상적으로 사용할 수 없게 된다.
create 명령어를 사용해서 centos 컨테이너를 생성한다. --name 옵션을 통해서 컨테이너의 이름을 설정한다.</description>
    </item>
    
  </channel>
</rss>
