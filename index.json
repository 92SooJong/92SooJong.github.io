[{"content":"Separate Chaining Separate Chaining는 충돌 해결을 위한 테크닉이다.\nLinked List를 사용하는 방법이다.\n이 방법을 사용하면 elements를 같은 slot에 넣을 수 있다.\n각 슬롯은 Linked List이다. 하나의 슬롯에 2개 이상의 elements를 넣어야 하는경우 유용하다.\nHow to Avoid Collision in Separate Chaining Method 가능하면 충돌을 최소화하는 Hash function을 설계하는게 중요하다. 좋은 hash function은 아래와 같다.\n충돌 최소화 계산하기 쉽고 속도가 빠르다. 해쉬 테이블에 균형있게 insert 된다. Key에 대해서 high load factor를 가진다. Time Complexity 검색시 O(1+load factor)의 시간 복잡도를 가진다.\n하나의 슬롯안에 여러 엘리멘츠가 있을 경우 Linked list를 검색하는 작업이 추가로 필요하다. 워스트 케이스는 모든 elements가 하나의 슬롯안에 들어가 있는 경우다. 이 경우 시간 복잡도는 O(n)이 된다.\n검색과 마찬가지로 삭제시에 O(1+load factor)의 시간 복잡도를 가진다. 워스트 케이스의 경우 O(n) 시간 복잡도를 가진다.\nLoad Factor 균일하게 Key가 slot에 분배 되어 있는 지 알려주는 지표다.\nLoad Factor= Total elements in hash table/ Size of hash table\nAdvantages Seperate Chaining은 가장 쉬운 방법이다.\nchain을 통해서 제한없이 elements를 추가할 수 있다.\nelements의 수를 예측할 수 없을때 사용하기 좋다.\nDisadvantages 균형있게 분배되지 않을 수 있다.\n따라서 공간 낭비가 발생할 수 있음.\n체인이 길어질 수록 시간 복잡도가 O(n)이 된다.\n","permalink":"https://92SooJong.github.io/posts/computer-science/separate-chaining/","summary":"Separate Chaining Separate Chaining는 충돌 해결을 위한 테크닉이다.\nLinked List를 사용하는 방법이다.\n이 방법을 사용하면 elements를 같은 slot에 넣을 수 있다.\n각 슬롯은 Linked List이다. 하나의 슬롯에 2개 이상의 elements를 넣어야 하는경우 유용하다.\nHow to Avoid Collision in Separate Chaining Method 가능하면 충돌을 최소화하는 Hash function을 설계하는게 중요하다. 좋은 hash function은 아래와 같다.\n충돌 최소화 계산하기 쉽고 속도가 빠르다. 해쉬 테이블에 균형있게 insert 된다. Key에 대해서 high load factor를 가진다. Time Complexity 검색시 O(1+load factor)의 시간 복잡도를 가진다.","title":"Separate Chaining"},{"content":"https://www.scaler.com/topics/data-structures/hashing-in-data-structure/\nTime complexity - O(log n)\nSpace complexity - O(n)\nKey - Value Key - An Identifier to uniquely identify the data(entity)\nValue - The actual Entity which we want to stroe.\nThis mapping helps to link easier/smaller key to a particular value\nHashing performs a transformation on this key, to return an Integer value which can be used as the memory address to place this Key-Value at.\nOn non-integeral keys, there are 2 steps involved.\nTransform non-integral key to integral value perform hashing What is hasing In data Structure Efficiently finding, storing data in an array.\nkey as input and returns us the memory address\nHash Table in Data Structure In data structure, hash tables are used for storing the key-value pairs.\nInstead of directly storing the keys in hash table, hasing comes into plcy, which runs the hash function converts these big Keys to the integer value \u0026lt;= size of Array. this Integer value is called hash index.\nhash function creates hash index. hash function have to return distinct indexes for every input.\nHashing Function in DBMS The memory location where these records are stored is known as data buckets or data blocks.\nMost of the time, the hash function uses the primary key to generate the address of the data block.\nWays to Calculate Hashing in Data Structure 1. Division Method Division method: HashFunction = Key % size\nE.g. if key=15, then 15%10=5 and 5\u0026lt;10 so we can insert this Data with key=15 at the 5th index of the array of size 10.\n2. Multiplication Method h(k) = floor( n( kA mod 1 ) ) k is key\nA is constant value between 0 and 1\nk=123 n=100 A=0.618033 (Has to be between 0 and 1) h(123) = 100 (123 * 0.618033 mod 1) = 100 (76.018059 mod 1) = 100 (0.018059) = 1 3. Universal Hashing Universal hashing means that we don’t use a fixed hash function, but there is a family of hash functions from which we can randomly pick any hash function.\n4. Folding Method By folding we mean that, if the array size = 100, that means 2-digit numbers can only fit inside it, so we fold the given key in parts of 2. I.e. if Key=20574 Then we will fold it in parts of 2, which will be: 20, 57, and 4. So to get an index \u0026lt; 100 from these parts, we can sum these up i.e. 20 + 57 + 4 = 81. So 81 is the index where this Key=20574 can be placed.\nPlease note that there can be cases where even after folding we get a number \u0026gt; size e.g. Key=56571 then breaking it down in parts of 2= 56+57+1=114\nNow we cant place this Data at index 114 inside the array of size 100, so we can either apply this algorithm again or can use the Division method(mostly used in such scenarios) to get 114%100=14 So this Data can be placed at the 14th Index of this array.\n5. Mid Square Method In this method, we basically square the given number and pick N middle numbers in that squared number, to find the index\nLet’s take N=2 and Array size=11. Hash(93) = 93^2 = 8649. Picking N(=2) middle elements i.e. 64 Now since 64\u0026gt;11, so we can apply the Division method to get 64%11=9. So 93 can be placed at 9th Index in the array of size 11.\n","permalink":"https://92SooJong.github.io/posts/computer-science/hashing-in-data-structure/","summary":"https://www.scaler.com/topics/data-structures/hashing-in-data-structure/\nTime complexity - O(log n)\nSpace complexity - O(n)\nKey - Value Key - An Identifier to uniquely identify the data(entity)\nValue - The actual Entity which we want to stroe.\nThis mapping helps to link easier/smaller key to a particular value\nHashing performs a transformation on this key, to return an Integer value which can be used as the memory address to place this Key-Value at.\nOn non-integeral keys, there are 2 steps involved.","title":"Hashing in Data Structure"},{"content":"2022-11-14 @ParameterizedTest, @MethodSource Jsoup 2022-11-15 2022-11-16 BigDecimal thymeleaf 주석 관련링크 ","permalink":"https://92SooJong.github.io/posts/etc/2022-11/","summary":"2022-11-14 @ParameterizedTest, @MethodSource Jsoup 2022-11-15 2022-11-16 BigDecimal thymeleaf 주석 관련링크 ","title":"What I've learned from work at November 2022"},{"content":"Redis Data Types Keys Redis의 Key는 바이너리 세이프. String, JPEG 파일까지 Key가 가능함. 공백 String도 유효한 Key key가 너무 긴건 추천하지 않는다. (메모리 측면이나 성능 측면에서 다 안좋음.) Key가 너무 짧은건 추천하지 않는다. u1000flw말고 user:1000:followers 처럼 읽기 좋게 써라. 스키마를 표기해주면 좋다. object-type:id user:1000 여러 단어를 붙여쓸땐 점이나 대쉬를 사용한다. comment:4321:reply-to 최대 Key size는 512MB이다 Strings key중에서 제일 단순한 형태. 초보자에게 친숙함. key 자체를 그냥 value로 쓸수도 있음. String을 또다른 String으로 할당하는 식 String은 HTML같은걸 캐싱하고 싶을때 유용하다. 1\u0026gt; set mykey somevalue 2OK 3\u0026gt; get mykey 4\u0026#34;somevalue\u0026#34; set을 쓰면 기존에 존재하던 데이터를 덮어씀. set은 몇가지 옵션을 제공한다. 이미 키가 존재하면 실패하도록 하는식.(그 반대도 가능) 1\u0026gt; set mykey newval nx 2(nil) 3\u0026gt; set mykey newval xx 4OK String에 대해서 몇가지 추가적인 명령어를 제공한다 1\u0026gt; set counter 100 2OK 3\u0026gt; incr counter 4(integer) 101 5\u0026gt; incr counter 6(integer) 102 7\u0026gt; incrby counter 50 8(integer) 152 INCR은 String을 Integer로 파싱하고, 1 증가시키는 명령어. (비슷하게 INCRBY, DECR, DECRBY가 있다) INCR은 원자성(atomic)을 보장한다. 따라서 race condition 문제가 발생하지 않음. 1\u0026gt; mset a 10 b 20 c 30 2OK 3\u0026gt; mget a b c 41) \u0026#34;10\u0026#34; 52) \u0026#34;20\u0026#34; 63) \u0026#34;30\u0026#34; MSET과 MGET을 통해서 한번에 여러개의 값을 가져오거나 세팅할 수 있음. (low latency 효과 기대) Altering and querying the key space 특정 타입에 의존하지 않는 명령어도 존재함.(수정, 조회) 예를들면 EXIST를 통해서 key가 존재하는지 확인할 수 있다. 1\u0026gt; set mykey hello 2OK 3\u0026gt; exists mykey 4(integer) 1 5\u0026gt; del mykey 6(integer) 1 7\u0026gt; exists mykey 8(integer) 0 TYPE 명령어를 통해서 key의 타입을 확인할 수 있다. 1\u0026gt; set mykey x 2OK 3\u0026gt; type mykey 4string 5\u0026gt; del mykey 6(integer) 1 7\u0026gt; type mykey 8none Key expiration key에 대한 타임아웃을 설정할 수 있다. time to live 또는 TTL이라고 부른다. 초 또는 밀리세컨드로 설정이 가능하다. key 만료와 관련된 정보는 디스크에 저장된다. Redis 서버가 멈추더라도 시간을 흐른것으로 간주한다(Redis가 key의 만료 시간을 저장하고 있음을 의미한다) 1\u0026gt; set key some-value 2OK 3\u0026gt; expire key 5 4(integer) 1 5\u0026gt; get key (immediately) 6\u0026#34;some-value\u0026#34; 7\u0026gt; get key (after some time) 8(nil) expire 명령어를 통해서 key의 만료 시간을 지정할 수 있다. 위 예시는 key라는 이름을 가진 key의 만료시간을 5초로 설정하는 예시다. set 명령어를 사용할때 옵션으로 만료 시간을 줄 수 있다. 1\u0026gt; set key 100 ex 10 2OK 3\u0026gt; ttl key 4(integer) 9 위 예시는 key-value를 생성함과 동시에 10초의 만료 시간을 지정한다. ttl 명령어를 통해서 남아있는 만료 시간을 조회할 수 있다. Lists List라는 용어는 언어별로 의미가 다르게 사용되는 경향이 있다. 파이썬의 list는 Linked Lists가 아닌 Array를 의미함. List는 연속적이며 순서가 있는 elements의 목록(List)를 의미한다. Redis의 list는 Linked lists를 의미한다. 따라서 새로운 elements를 추가하는데 있어서 속도가 상수 시간으로 보장된다. index를 통한 접근은 단점이다. 만약 인덱스를 통한 접근이 중요하다면 Sorted sets 타입을 사용해라. First steps with Redis Lists The LPUSH command adds a new element into a list, on the left (at the head) 1\u0026gt; rpush mylist A 2(integer) 1 3\u0026gt; rpush mylist B 4(integer) 2 5\u0026gt; lpush mylist first 6(integer) 3 7\u0026gt; lrange mylist 0 -1 81) \u0026#34;first\u0026#34; 92) \u0026#34;A\u0026#34; 103) \u0026#34;B\u0026#34; In one time, you can add multiple elements. 1\u0026gt; rpush mylist 1 2 3 4 5 \u0026#34;foo bar\u0026#34; 2(integer) 9 3\u0026gt; lrange mylist 0 -1 41) \u0026#34;first\u0026#34; 52) \u0026#34;A\u0026#34; 63) \u0026#34;B\u0026#34; 74) \u0026#34;1\u0026#34; 85) \u0026#34;2\u0026#34; 96) \u0026#34;3\u0026#34; 107) \u0026#34;4\u0026#34; 118) \u0026#34;5\u0026#34; 129) \u0026#34;foo bar\u0026#34; pop is the operation of both retrieving the element from the list, and eliminating it from the list at the same time. 1\u0026gt; rpush mylist a b c 2(integer) 3 3\u0026gt; rpop mylist 4\u0026#34;c\u0026#34; 5\u0026gt; rpop mylist 6\u0026#34;b\u0026#34; 7\u0026gt; rpop mylist 8\u0026#34;a\u0026#34; etc Redis can persist your data either by periodically dumping the dataset to disk. You can also disable persistence if you just need a feature-rich, networked, in-memory cache.\nExternal programs talk to Redis using a TCP socket and a Redis specific protocol.\nyou need to download and install a Redis client library for your programming language.\n","permalink":"https://92SooJong.github.io/posts/redis/redis-basic/","summary":"Redis Data Types Keys Redis의 Key는 바이너리 세이프. String, JPEG 파일까지 Key가 가능함. 공백 String도 유효한 Key key가 너무 긴건 추천하지 않는다. (메모리 측면이나 성능 측면에서 다 안좋음.) Key가 너무 짧은건 추천하지 않는다. u1000flw말고 user:1000:followers 처럼 읽기 좋게 써라. 스키마를 표기해주면 좋다. object-type:id user:1000 여러 단어를 붙여쓸땐 점이나 대쉬를 사용한다. comment:4321:reply-to 최대 Key size는 512MB이다 Strings key중에서 제일 단순한 형태. 초보자에게 친숙함. key 자체를 그냥 value로 쓸수도 있음. String을 또다른 String으로 할당하는 식 String은 HTML같은걸 캐싱하고 싶을때 유용하다.","title":"Redis Data Types(Stirng, Lists)"},{"content":"Connection pooling means a pool of Connection Objects.\nConnection pooling is based on an object pool design pattern.\nThe cost of creating new objects is higher So application creates an object in advance and place them in Pool.\nWhenever application requires objects, it(application) acquires them from the pool rather than creating a new one.\nWe can create our own implementations of Connection pooling.\nAny connection pooling framework needs to do three tasks.\nCreating Connection Objects Manage usage of created Objects and validate them. Release/Destroy Objects Following 3 Connection Pooling are commonly used in Java Application\nApache Commons DBCP2 HikariCP C3P0 Data Source Data Source is entry point to Connection Pool\nData source has url, username, password and etc. for data connection\nData source creates connection pool\n","permalink":"https://92SooJong.github.io/posts/database/connection-pooling/","summary":"Connection pooling means a pool of Connection Objects.\nConnection pooling is based on an object pool design pattern.\nThe cost of creating new objects is higher So application creates an object in advance and place them in Pool.\nWhenever application requires objects, it(application) acquires them from the pool rather than creating a new one.\nWe can create our own implementations of Connection pooling.\nAny connection pooling framework needs to do three tasks.","title":"Connection Pooling"},{"content":"Interpreting and Classloading JVM은 stack-based interpreted machine이다. 이 뜻은 CPU같은 물리적 하드웨어를 뜻하는게 아니라 execution stack을 의미한다. 그리고 이 스택에 존재하는 값들을 통해서 계산을 수행한다.\n예를들어 java HelloWorld 커맨드를 실행하면, 운영체제는 virtual machine process(the java binary)를 실행한다. 이 과정에서 자바 가상 환경 세팅과 초기화를 수행한다. 이 결과로 HelloWorld.class 파일을 생성한다.\n생성된 클래스 파일의 진입점은 main() 메소드가 될것이다. 클래스 파일을 제어하기 위해선 가상 머신을 실행하기 전에 클래스 파일이 로딩되어야한다.\n이 작업을 위해 Java Class Loading 메커니즘이 사용된다. 새로운 Java process가 실행될때 클래스로더 체인이 사용되며 가장 먼저 실행되는 initial loader는 Bootstrap 클래스로더이다.\nBootstrap 클래스로더는 core Java runtime에 있는 클래스들을 포함하고 있다. 자바 8버전 까지는 이것들이 rt.jar 파일로부터 로딩된다. (런타임의 약자인듯?) 자바 9버전 이후론 모듈화 되었고, 클래스로더 컨셉 자체가 바껴버렸다.\nBootstrap 클래스 로더의 핵심은 최소한의 class만 로딩한다는 것이다. ( java.lang.Object, Class, Classloader같은 애들을 말함.) 이 클래스들은 시스템의 다른 부분을 불러올 수 있도록 도와주는 역할을 주로 한다. (클래스 로더도 하나의 오브젝트이기 때문에 최소한의 클래스 세트가 필요함.)\n그다음으로 Extension 클래스 로더가 생성된다. 확장 클래스로더는 부모를 부트스트랩 클래스로더로 정의하고, 부모에게 자신을 위임합니다. ( 즉, 부모 클래스 로더를 확장하는 역할을 함 )\n그렇게 흔히 사용되는 클래스로더는 아니다. 하지만 오버라이드 기능을 제공할 수 있고, 특정 운영체제에 필요한 네이티브 코드를 작성해야할 때 사용할 수 있다.\n마지막으로 Application 클래스로더가 생성된다. 클래스 Path에 정의되어 있는 유저 클래스를 로딩하는 책임을 가진다. 어쩔땐 System 클래스로더로 불리기도하는데 이 용어는 적절하지 않으므로 피하도록 하자. (시스템 클래스를 호출한다고 오해할 여지가 생긴다. 시스템 클래스를 호출하는 역할은 Bootstrap 클래스로더가 수행한다.)\n자바는 의존성을 통해 새로운 클래스들을 로드한다. 프로그램을 실행하다가 처음으로 마주치는 그순간에…\n클래스로더가 적절한 클래스를 찾는걸 실패하면 행위는 부모 클래스로더로 위임된다.\n만약 이러한 체인이 Bootstrap 클래스로더까지 도달하고 적절한 클래스를 찾지못한다면 ClassNotFoundException이 발생할 것이다.\n자바는 클래스를 단 한번만 로드하며, Class 오브젝트가 생성된다. 대표한다 클래스를 런타임 환경에서.\n하지만, 서로 다른 클래스 로더라면 잠재적으로 같은 클래스가 각각 호출된다. ( 즉 두번 이상 호출되는 일이 있음)\n그결과 시스템에 있는 클래스는 클래스 로더와 패키지명을 통해서 유일성이 식별된다.\nExecuting Bytecode 자바 소스코드가 실행 전까지 많은 변환작업이 있다는걸 아는게 중요하다.\n첫번째는 compilation step이다. 이 과정을 위해 Java compiler인 javac 가 사용된다.\njavac의 역할은 Java code를 바이트 코드를 포함한 .class 파일로 변환하는것이다.\n아주 최소한의 최적화 작업이 이 과정에서 이뤄진다. 결과로 나온 바이트 코드는 꽤 읽을 수 있는 수준이다. disassembly 툴을 사용해서 표준인 javap 같은걸 사용하면 말이다.\n바이트 코드는 중간단계를 나타낸다. 즉 특정 하드웨어와 엮여 있는 상태가 아니다.\n하드웨어와 디커플링을 통해서 포터블한 능력을 제공하게 된다. JVM 상에서 돌아가기 때문에 하드웨어에 의존적이지 않다. JVM을 사용했을때 중요한 포인트중 하나다.\n컴파일된 클래스파일은 잘 정의된 구조를 가지고 있다. 클래스 파일은 VM 명세에 지정된 컴포넌트로 구성된다.\n모든 클래스들은 매직넘버 0xCAFEBABE로 시작한다. 첫 4바이트는 클래스 파일 형식에 대한 적합성을 나타낸다. 그뒤에 오는 4 바이트는 클래스 파일을 컴파일하는데 사용되는 minor , major 버전을 나타낸다. 이를 이용해서 클래스로더는 JVM과 버전이 매칭이 되는지 확인할 수 있다.\n만약 버전이 매칭되지 않는다면, UnsupportedClassVersionError가 발생한다. (JVM이 컴파일된 클래스파일을 사용하기엔 낮은 버전이라는 걸 뜻한다.)\nConstant pool은 상수 정보를 가지고 있다. 예를들면 클래스, 인터페이스, 필드 이름과 같은 것들이다. JVM이 코드를 실행할때 값을 얻기 위해 상수 테이블이 사용된다. ( 어떤 메모리에 의존하지 않음 )\nAccess flag들은 modifier가 클래스에 접근할 수 있는지를 검사한다. 예를 들면 final 클래스면 서브 클래스를 가질수 없도록 하는 역할들을 수행한다.\n인터페이스인지 추상클래스인지 검사함. 또한, enum인지 어노테이션 타입인지 검사한다.\nThis class, Superclass, Interface는 constant pool의 인덱스로 존재한다. 인지하기 위해 타입의 계층구조를…\n아래 그림을 통해서 좀더 바이트 구조를 쉽게 암기할 수 있다.\n아래 간단한 코드를 컴파일 해보자.\n1public class HelloWorld { 2\tpublic static void main(String[] args) { 3\tfor (int i = 0; i \u0026lt; 10; i++) { 4\tSystem.out.println(\u0026#34;Hello World\u0026#34;); 5\t} 6} 생성된 클래스 파일을 javap를 통해서 확인해보자.\n클래스 파일에 대한 바이트 코드를 확인할 수 있다. 메소드가 두개로 보이는데 컴파일 과정에서 자동으로 생성자 메소드가 생성되었기 때문이다.\n생성자에 있는 aload_0는 this 에 대한 레퍼런스를 뜻하며 스택의 첫번째에 위치하게 됩니다.\ninvokespecial 명령어는 슈퍼 생성자를 호출해서 오브젝트를 생성하는 역할을 합니다. 위 예시에서는 default가 실행되는데 이때는 Object 클래스의 생성자가 호출됩니다.\nmain 메소드에 있는 iconst_0는 상수인 0을 evaluation 스택에 넣는다.\nistore_1은 스택에 있던 상수 값을 지역 변수 오프셋 1번에 저장한다. (for 문에 있던 i 변수를 의미한다.)\n사실 지역변수의 오프셋은 0부터 시작한다. 하지만 인스턴스 메소드에선 0번째 오프셋은 항상 this가 된다.\n오프셋 1에 있는 변수는 스택으로 로딩된다. 그리고 bipush 10을 통해서 변수 10이 비교를 위해 스택으로 로딩된다. 비교는 if_icmpage( if integer compare greater or equal ) 명령어를 통해 수행하게된다. 22의 의미는 테스트 성공시 22로 이동하라는 뜻이다. ( 현재 코드에선 22는 return이다. )테스트는 현재 정수가 10보다 크거나 같을때만 성공하게 된다.\n몇번의 루프동안 조건 검사는 계속 실패하게 되므로 8번 작업을 수행하면된다. getstatic #2는 System.out 을 의미하며 이후에 있는 ldc #3(상수 pool #3) 에 존재하던 “Hello World” 문자를 가져와 출력한다.\ninvokevirtual은 인스턴스 메소드를 실행시킨다.\niinc는 정수의 증가(integer increment)를 의미하며, 1씩 증가하며 1번에 있는 istore_1을 업데이트한다.\ngoto는 2번째 명령어로 포인터를 옮기는 역할을 한다.\n이 작업은 if_icmpge가 성공할때까지 계속해서 수행된다.\nIntroducing HotSpot 1999년 4월 Sun은 성능과 관련된 용어에 대해서 변경사항을 발표했다.\nHotSpot 가상 머신은 자바의 핵심기능이며, C와 C++과 비견될만한 성능 변화를 가져왔다.\n런타임시에 발생하는 동작을 실시간으로 분석하고 이를 성능 최적화에 활용한다.\nIntroducing Just-In-Time Compilation 자바 프로그램은 바이트 코드 인터프리터 위에서 실행된다. 바이트코드 인터프리터는 가상화된 스택 머신위에서 명령어를 실행한다.\n이렇게 하드웨어(CPU, 레지스터 등)에 직접 접근하지 않고 추상화 하는 방식은 클래스 파일이 포터블할 수 있도록 해준다.(따라서 코드가 하드웨어에 의존적이지 않아도된다.) 하지만 최대의 성능을 내기 위해선 CPU가 직접 코드를 실행하도록 해야한다.\n이런 문제를 HotSpot은 바이트 코드를 네이티브 코드로 변환하는 방식을 몇 가지 unit을 통해서 해결했다. HotSpot VM 내부에 있는 컴파일 unit들은 메소드와 루프이다. 이것은 Just-In-Time(JIT)으로 많이 알려져 있다.\nJIT 컴파일은 구동중인 application을 모니터링하면서 진행되는데, 여기서 가장 자주 실행되는 코드의 부분을 찾는다. 특정 메소드의 실행이 threshold를 넘어가게 되면, profiler가 코드의 특정 영역을 컴파일하고 최적화 작업을 수행한다.\nJIT는 최적화를 인터프리터 단계에서 수집된 정보를 기반으로 최적화를 수행하기 때문에 좀 더 객관적인 정보를 통한 최적화가 가능하다는 장점을 가진다. 또한 수많은 엔지니어링 기간을 보냈기때문에 매 버전마다 개선된 JIT을 사용할 수 있다.\nC++ 같은 언어는 성능이 예상가능하다. 하지만 사용자는 상당한 복잡성을 가진 low-level을 다뤄야하는 단점이 있다. 또한 “예상 가능한”이 더 좋다는 것을 의미하지도 않는다. (AOT vs PGO에 대해서 살펴보기)\nHotSpot 컴파일은 VM에 제공하는 두개의 핵심 기능중 하나이다. 또다른 하나는 메모리 관리이다.\n","permalink":"https://92SooJong.github.io/posts/java/java-optimizing/chapter2-overview-of-the-jvm/","summary":"Interpreting and Classloading JVM은 stack-based interpreted machine이다. 이 뜻은 CPU같은 물리적 하드웨어를 뜻하는게 아니라 execution stack을 의미한다. 그리고 이 스택에 존재하는 값들을 통해서 계산을 수행한다.\n예를들어 java HelloWorld 커맨드를 실행하면, 운영체제는 virtual machine process(the java binary)를 실행한다. 이 과정에서 자바 가상 환경 세팅과 초기화를 수행한다. 이 결과로 HelloWorld.class 파일을 생성한다.\n생성된 클래스 파일의 진입점은 main() 메소드가 될것이다. 클래스 파일을 제어하기 위해선 가상 머신을 실행하기 전에 클래스 파일이 로딩되어야한다.\n이 작업을 위해 Java Class Loading 메커니즘이 사용된다.","title":"Chapter2. Overview of the JVM"},{"content":"들으면서 퀵하게 적은 내용을 다시 쓴 거라 정리하는 과정에서 나의 해석이 들어갔을 가능성 있음.\n돌아보니 개발 스킬보다는 행동양식이 더 중요하다. 태도가 준비가 되어있지 않으면 스킬이 좋아도 의미가 없다. 스타트업의 초기 멤버는 사실상 주니어급들이다. 그러다 보니 면접으로 기술자를 뽑을때 주니어가 주니어를 뽑는 일이 발생한다. 이 경우 사람은 늘어 나는데 생산성이 나오지 않는 현상이 발생한다. 자신보다 능력이 좋은 사람을 뽑을 수 있는 용기가 있어야한다. 완벽주의자는 위로 갈수록 힘들어진다. 모든 일을 자신이 다 하려고 하면 안된다. 내 생각에는 완벽주의는 장점이 아니다. 고위직(?)은 성실한것 보다는 방향 설정이 생명이다. 승진을 하다보면 자신의 장점이 단점이 되는 순간이 있는데 이를 인지하는 사람은 극소수다. (말단 직원일땐 완벽주의가 좋을진 몰라도 승진을 하다보면 단점으로 작용하는 경우가 더 많다.) 내가 생각하는 나의 장점을 단점이라고 지적해주는 사람이 있다면 새겨서 듣고 나를 돌아봐라. 어떤 행동을 할때 항상 리턴을 생각하는 습관을 가지자. 나의 행동양식에 대해 피드백을 주는 사람이 있다는건 좋은일이며, 나도 이를 악의를 가지고 받아들여선 안된다. 컴포트 존에서 벗어나라 불안함에 선행학습을 무리하게 하는 경향이 있는데 가능하면 현재에 주어진 일을 멋지게 해내라. 오지도 않은 미래에 대해서 너무 고민하지 마라. 조바심 내지마라. 특히 한국인이 나이에 연연하는 경향이 있다. 자기가 만난 사람중에 20대도 나이가 많다고 생각하는 사람이 있을정도였다. 커리어는 시작점 보단 어디서 마무리를 하느냐가 더 중요하다. 우리 나라 사람들이 질문을 주저하는 경향이 있다. 자기검열을 너무 하는것 같다. 내가 나를 평가하지 마라. 실리콘 밸리에 있던 직원들이 자신이 승진을 하지 못하는 이유를 리더에게 직접 물어보더라.(”이번에 승진을 하지 못했는데 어떤점이 부족한가요?”) 반면 한국인은 자신의 부족한 점을 스스로 판단하고 부족한 점을 메꾼 다음에 리더에게 간다. 자기 스스로 생각하지 말고 제 3자에게 자신의 부족한 점을 확인하고 개선해라. 좋은 질문 문화를 가진 팀이 되는건 간단하다. 순진한 아이처럼 물어보는 사람이 팀에 단 한명만 있으면 된다. (”뭐 이런것도 물어봐?” 싶은걸 물어보는 아이같은 사람. 아이는 절대 눈치 보지 않는다!) 자신이 이해한게 맞는지 확인하는 화법도 좋다. ( 저는 이렇게 이해했는데 맞게 이해한건가요? 라고 되묻기 ) 요즘 커리어는 사다리가 아니라 정글짐이다. 즉, 떨어져도 다시 올라갈수 있고, 언제든지 옆으로 옮겨갈 수 있다. [ 이건 실리콘 밸리의 특징인것 같다고 덧붙이심. ] 아마존의 의사 결정 방식은 one way door, two way door로 나뉨. [ 설명 해주긴 하셨는데 너무 길어서 구글링 ㄱㄱ] 학원 다니면서 강의 듣고 하는거 보다 좋은 사람이 있는 규모 작은 회사에 가는게 훨씬 낫다. 개발을 너무 수능 공부 하듯이 하지말고 일단 부딪혀라. 복리가 있는 일은 빨리 시작해라. ( 휴먼 네트워킹, 책읽기, 글쓰기 ) 다만 복리가 있는 일은 초반에 전혀 티가나지 않는다. 꾸준히 하는게 생명이다!! 스타트업은 갈팡질팡하고 우왕좌왕 하지만 일처리에 있어 속도감이 있다. 큰회사는 대부분 느리게 굴러감. 하지만 대부분 사람들은 큰 회사에 입사하는 로망이 있다. 내가 느끼기에 규모가 큰데 속도감 있게 일하는 회사는 AWS와 메타 였다. 구글은 빠르게 굴러간다는 느낌은 못받았다. (아마존의 일하는 방식을 설명하는 책 Working Backwards) 회사의 명성보다는 같이 일하는 사람이 누구인지가 더 중요하다. 남과 비교하지 말고 어제의 나와 비교해라. 기술 공부를 열심히 하면 영원히 일을 할 수 있을것 같지만 전혀 아니다 매니징을 반드시 해봐야 한다. 기술 공부를 평소에 잘 해뒀다면 다른 업무를 하다가 다시 돌아와도 문제 없다. 새로 채용한 사람을 잘 온보딩 시키기 위해선 90일 이내에 성취를 줘야한다. ","permalink":"https://92SooJong.github.io/posts/seminar/%ED%95%9C%EA%B8%B0%EC%9A%A9%EB%8B%98-%EB%AC%B4%EC%8B%A0%EC%82%AC-20221020/","summary":"들으면서 퀵하게 적은 내용을 다시 쓴 거라 정리하는 과정에서 나의 해석이 들어갔을 가능성 있음.\n돌아보니 개발 스킬보다는 행동양식이 더 중요하다. 태도가 준비가 되어있지 않으면 스킬이 좋아도 의미가 없다. 스타트업의 초기 멤버는 사실상 주니어급들이다. 그러다 보니 면접으로 기술자를 뽑을때 주니어가 주니어를 뽑는 일이 발생한다. 이 경우 사람은 늘어 나는데 생산성이 나오지 않는 현상이 발생한다. 자신보다 능력이 좋은 사람을 뽑을 수 있는 용기가 있어야한다. 완벽주의자는 위로 갈수록 힘들어진다. 모든 일을 자신이 다 하려고 하면 안된다.","title":"한기용님-무신사-20221020-강연정리"},{"content":"Infra Overview 리전(Region)과 가용영역(Availability Zone) 데이터센터의 모음 또는 그룹을 의미하며, AWS가 전 세계에서 데이터 센터를 클러스터링하는 물리적 위치를 뜻합니다.\n2022년 현재 27개의 리전, 87개 가용영역(논리적 데이터 센터)이 존재합니다.\nAWS 리전은 가용성, 확장성, 내결함성을 위해서 다중 가용역역으로 구성되며,따라서 리전내에 여러개의 가용영역(AZ)이 존재합니다. 가용영역은 완전히 격리된 환경에 구축되어 앞서 말한 가용성, 확장성, 내결함성을 충족하도록 설계됩니다.\n콘텐츠 전송 네트워크(CDN) 최종 사용자에게 더 짧은 지연 시간으로 콘텐츠를 전송하기 위해 AWS CloudFront라는 CDN을 구축했습니다. CDN을 통해서 고객이 실제로 위치한 가장 가까운 곳에 캐싱을 제공하도록 합니다.\n글로벌 네트워크 대양 횡단 케이블로 연결된 이중화된 100GbE로 구축했으며, 대륙횡단 케이블을 직접 설치하고 운용합니다.\n전용 연결(Direct Connect) 데이터 센터, 사무실 또는 코로케이션 환경과 AWS 리전 사이에 직접 연결을 제공합니다.\nAWS Network VPC Virtual Private Cloud의 약자이며 사용자가 정의한 가상의 네트워크 공간을 의미합니다.\nIP와 Subnet의 범위, 라우팅 테이블 정의 등 완전한 네트워크 제어가 가능합니다.\nVPC 내의 모든 EC2 인스턴스들은 Private IP가 부여되며, 이 뜻은 모든 EC2는 VPC내에 속해야함을 의미합니다.\n물론 EC2 인스턴스에 Public IP를 할당할 수도 있습니다.(여기선 비용이 발생합니다.) 앞서 말한 CDN은 어떤 리전에도 속해있지 않습니다. S3는 VPC에 속하지 않고, 리전안에만 속해있습니다. 환경을 구성할때 이런 부분을 먼저 파악하고 작업해야합니다.\nVPC안에 서브넷은 항상 있어야합니다.\n서울에는 총 6개의 가용영역(AZ)이 있습니다. 그중 2개는 Wave length라 부르며 이동 통신사의 국사안에 존재한다.(SKT에 2개) Wave length는 자율 주행서비스처럼 고속 인터넷이 필요한 서비스를 위해 만들어 졌습니다.\nVPC를 생성하는데 있어 첫번째 작업은 CIDR(Classless Inter-Domain Routing) 블록 주소 대역을 설정하는 것입니다. CIDR 방식을 통해 VPC 범위를 설정하고 같은 방법으로 VPC내의 Subnet을 구성할 수 있습니다.\n그다음 인터넷 게이트웨이를 생성합니다. 인터넷 게이트웨이를 통해서 VPC의 내부 자원을 외부로 보낼 수 있습니다.\nPrivate Subnet이 외부와 통신하기 위해 Public Subnet에 NAT Gateway를 구성할 수 있습니다. (Private Subnet과 외부 자원이 직접 통신하는것은 보안상 적절하지 않습니다.)\nAWS Compute Elastic Compute Cloud(EC2) Amazon Elastic Compute Cloud를 줄여서 EC2라고 부릅니다. EC2는 하이퍼바이저를 통해 가상화된 운영환경을 제공하는 기술.\nEC2는 기본적으로 AMI와 EBS를 통해 구성됩니다.\nAmazon Machine Image(AMI) 루트 볼륨을 구성하는 템플릿입니다. 즉, EC2 생성을 위한 이미지를 뜻합니다. (OS, 어플리케이션 등) Elastic Block Storage(EBS) EC2 인스턴스에서 사용할 물리적 스토리지를 뜻합니다. 하나의 EBS 볼륨은 하나의 인스턴스에만 연결됩니다. 스냅샷을 통해 특정 시점 백업이 가능합니다. EC2의 상태는 크게 아래 3개로 구성됩니다.\n실행중(Running) 정지됨(Stopped) 정지됨 상태는 EBS 볼륨을 루트로 사용하는 인스턴스만 가질 수 있는 상태입니다. EC2가 정지 되었더라도 EBS 볼륨에 대한 과금은 발생 될 수 있습니다. 정지됨에서 실행중으로 갈때 새로운 물리 서버를 찾는 과정이 있는데 이때 이전에 썻던 물리 서버를 사용하지 않게된다. IP의 변경이 발생할 수 있습니다. 종료됨(Terminated) 인스턴스가 완전히 제거된 상태를 뜻하며, 시작이나, 정지가 불가능합니다. 네이밍을 통해 EC2자원의 특징을 파악할 수 있습니다.\n예를 들어 M5d.xlarge라는 자원이 있다면 아래와 같이 문자열 자리별로 인스턴스 유형을 파악할 수 있습니다.\n상세한 정보는 아래 사이트에서 확인 가능합니다. AWS에선 매년 개선된 인스턴스를 만들어 내기 때문에 가능하면 최신 세대의 인스턴스를 선택하는것이 비용절감에 효과적입니다.\nhttps:/aws.amazon.com/ko/ec2/instance-types/\nElastic Load Balancing(ELB) 애플리케이션 트래픽을 분산해주는 역할을 하는 Computing 서비스입니다.\n종류로는 Application, Network, Classic으로 총 3개가 있습니다.\n각 종류별 특징을 살펴보면 아래와 같습니다.\nApplication Load Balaner Layer 7(HTTP, HTTPS) 로드밸런싱을 담당합니다. EC2, Container, AWS Lambda, Private IP주소에 대한 로드 밸런싱을 지원합니다. Network Load Balaner Layer 4(TCP, UDP)의 로드밸런싱을 담당합니다. EC2, Container, Private 주소에 대한 로드 밸런싱을 지원합니다. Classic Load Balaner Layer 4,7을 모두 커버하는 로드 밸런서 입니다. (잘 사용하지 않는지 수업에서 별다른 언급이 없었습니다.) EC2 Auto Scaling EC2 Auto Scaling를 통해 변화하는 수요에 동적으로 대응하고 비용을 최적화합니다.\nUser Data EC2의 User Data 기능을 통해서 인스턴스 실행시 쉘 스크립트를 실행할 수 있습니다.\nLaunch templates Launch templates을 작성해서 EC2 인스턴스를 생성할 수 있습니다.\nCloudWatch CloudWatch를 통해 AWS의 리소스 및 애플리케이션을 모니터링 할수 있습니다.\nAWS Database 쿼리 응답 시간 = I/O 타임 + cpu 타임 + 대기 이벤트\n좋은 쿼리 = 적은 데이터 블럭을 빠른 I/O로 읽는 것\n데이터 트렌드 매 5년마다 약 10배 증가하는 데이터가 증가하고 있으며, DevOps 도입으로 인한 데이터베이스에 대한 변화율이 증가 하고 있습니다.\nAmazon RDS Amazon RDS는 가장 많이 선호하는 6가지 데이터베이스( Amazon Aurora, MySQL, PostgreSQL, MariaDB, SQLServer, Oracle)엔진을 갖춘 관계형 데이터 베이스입니다.\n몇 번의 클릭만으로 하드웨어 프로비저닝, 패치, 백업, 복구, 확장, 고가용성 등의 작업이 가능합니다. 또한, Built-in 된 모니터링 및 보안 기능을 제공합니다.\n물리적으로 분리된 가용 영역에 standby 데이터베이스를 운영하여 가용성을 높입니다. (다중 AZ방식)\n또한 읽기전용 복제본 생성을 통해서 읽기 업무에 대한 워크로드 부하를 완화합니다. 이 기능을 통해서 다른 지역의 애플리케이션에 데이터를 제공할 수 있으며, 장애 발생시엔 빠른 복구를 위해 읽기 전용 복제본을 마스터로 승격할 수 있습니다. (읽기전용 복제본 생성방식)\n다중 AZ방식과 읽기전용 복제 방식의 특징은 아래와 같습니다.\nAWS Storage Elastic Block Store(EBS) EBS는 AWS에서 제공하는 블록 스토리지입니다.\nEC2에서 사용하도록 설계된 되었으며, EBS 볼륨을 통해서 파일 시스템을 생성하거나 블록 디바이스 자체로 활용합니다.\n고성능 대규모 데이터처리, 트랜잭션 집약적인 워크로드 처리를 위해 사용됩니다.\nEC2는 데이터 손실 방지를 위해 가용 영역 내에서 자동으로 볼륨을 복제합니다.\nElastic File System(EFS) EFS는 AWS에서 제공하는 파일 스토리지입니다. 디렉토리 구조로 파일을 저장하며, 스토리지 레벨에서 파일 시스템을 생성합니다.\nSimple Storage Service(S3) S3는 AWS에서 제공하는 오브젝트 스토리지입니다. REST 기반의 API 호출을 통해서 데이터에 접근할 수 있습니다.\nS3의 데이터는 3곳 이상의 물리적으로 분리된 가용 영역에 저장되어 있습니다. 또한 S3는 Multi-destination 복제를 통해 오브젝트를 동일 리전 또는 다른 리전에 복사 합니다.\nS3의 내구성을 99.999999999%입니다.\n","permalink":"https://92SooJong.github.io/posts/aws/general-immersion-day/","summary":"Infra Overview 리전(Region)과 가용영역(Availability Zone) 데이터센터의 모음 또는 그룹을 의미하며, AWS가 전 세계에서 데이터 센터를 클러스터링하는 물리적 위치를 뜻합니다.\n2022년 현재 27개의 리전, 87개 가용영역(논리적 데이터 센터)이 존재합니다.\nAWS 리전은 가용성, 확장성, 내결함성을 위해서 다중 가용역역으로 구성되며,따라서 리전내에 여러개의 가용영역(AZ)이 존재합니다. 가용영역은 완전히 격리된 환경에 구축되어 앞서 말한 가용성, 확장성, 내결함성을 충족하도록 설계됩니다.\n콘텐츠 전송 네트워크(CDN) 최종 사용자에게 더 짧은 지연 시간으로 콘텐츠를 전송하기 위해 AWS CloudFront라는 CDN을 구축했습니다. CDN을 통해서 고객이 실제로 위치한 가장 가까운 곳에 캐싱을 제공하도록 합니다.","title":"General Immersion Day(10/18) 정리"},{"content":"정의 퍼블릭 키와 프라이빗 키로 구성되어 있으며 Amazon EC2 인스턴스에 연결할 때 자격 증명 입증에 사용하는 보안 자격 증명 집합이다. 설명 퍼블릭 키는 EC2 인스턴스에 생성된다. 프라이빗 키는 사용자의 로컬에 생성된다. 사용자는 프라이빗 키를 통해 EC2 인스턴스와 SSH 연결을 수행할 수 있다. 따라서 사용자는 프라이빗 키를 보안이 유지되는 장소에 저장해둬야한다. EC2 인스턴스가 시작되면 ~/.ssh/authorized_keys에 퍼블릭 키가 생성된다. 로컬에 생성된 키페어를 잃어버리면 찾을 방법이 없다. 새로 키페어를 생성해야한다. 프라이빗 키의 확장자는 .pem이다. ( putty를 통해 접속을 하기 위해선 .pem파일을 .ppk로 변환해야한다.) ","permalink":"https://92SooJong.github.io/posts/aws/keypair/","summary":"정의 퍼블릭 키와 프라이빗 키로 구성되어 있으며 Amazon EC2 인스턴스에 연결할 때 자격 증명 입증에 사용하는 보안 자격 증명 집합이다. 설명 퍼블릭 키는 EC2 인스턴스에 생성된다. 프라이빗 키는 사용자의 로컬에 생성된다. 사용자는 프라이빗 키를 통해 EC2 인스턴스와 SSH 연결을 수행할 수 있다. 따라서 사용자는 프라이빗 키를 보안이 유지되는 장소에 저장해둬야한다. EC2 인스턴스가 시작되면 ~/.ssh/authorized_keys에 퍼블릭 키가 생성된다. 로컬에 생성된 키페어를 잃어버리면 찾을 방법이 없다. 새로 키페어를 생성해야한다. 프라이빗 키의 확장자는 .","title":"Key Pair"},{"content":"개요 Amazon Web Service 클라우드 컴퓨팅 서버리스(Serverless) 기능 지원 클라우드가 서버를 작동하고 메모리 할당을 효율적으로 수행함. 계정 만들기 사용하는 만큼 비용 지불 (As You Pay Go) Free-tier는 일종의 데모버전 ( 무료 ) 루트(Root) 사용자. 전지전능한 사용자. 권한부여나 다른 사용자를 만듦. IAM이란? IAM은 Identity and Access Management의 약자이다. 유저를 관리하고 접근 레벨 및 권한에 대한 관리를 해준다. 다른 유저를 생성할 수 있는데 유저에 대한 접근키와 비밀키를 제공한다. 접근키는 user_id , 비밀키는 password라고 생각하면 된다. Granular Permission(세밀한 접근) 테이블 생성, 삭제와 같은 세부적인 권한을 부여할 수 있다. 비밀번호를 수시로 변경 가능케 해준다. Multi-Factor Authentication(다중 인증) 기능. 비밀번호 뿐만아니라 페북,구글을 통해 추가적인 사용자 인증을 수행함. 유저뿐만 아니라 그룹,유저,역할, 정책을 생성할 수 있다. 그룹 : 하나 또는 다수의 유저가 존재 유저 : 패스 역할 : 하나 혹은 다수의 정책을 지정할 수 있다.(정책의 집합체) 유저는 역할을 가짐으로써 권한을 부여받는다. 정책 : JSON 형태로 된 다큐먼트를 가르키며, 접근에 대한 세부적인 설정을 가진 문서라고 보면된다. IAM은 Universal하다. (지역설정이 필요없다.) IAM 정책 시뮬레이터 개발환경(Staging or Develop)에서 실제환경(Production)으로 빌드하기전 IAM 정책이 잘 작동되는지 테스트하기 위함 IAM과 관련된 문제들을 디버깅하기에 최적화된 툴이다. ( 이미 실제로 유저에 부여된 다양한 정책들도 테스트 가능 ) ( 정책시뮬레이터 캡쳐본 첨부하기 ) IAM 실습하기 액세스 키 – 프로그래밍 방식 액세스\n액세스 키 ID 및 비밀 액세스 키를 부여받는다. 해당 키를 통해서 서비스나 개발 도구에 접근 가능함. 암호 – AWS 관리 콘솔 액세스 비밀 액세스키는 한번 잃어버리면 찾을 수 없다. 사용자를 다시 만들어야함! 그룹을 생성한다. ( 이후 사용자와 그룹을 매핑한다 ) 역할을 생성하는 화면\n역할은 사용자가 어떤 서비스를 이용할지 셋팅할 수 있다. (역할 사진) 정책을 생성하는 화면\n리소스 선택에서는 서비스에서 사용가능할 기능들을 선택하는 곳이다.\nEC2란? Elastic Compute Cloud 지불 방법은 On-demand(시간 단위로 가격이 고정되어 있음) , Reserved(한정된 EC2 용량 사용 가능, 크기 조절 불가), Spot(입찰 가격 적용, 인스턴스의 시작과 끝기간이 전혀 중요하지 않을때 사용 ) EC2를 사용하기 위해 EBS라는 디스크 볼륨을 요구한다. EBS는 EC2에 부착되어 있는 하드디스크라 생각하면 된다. EBS Elastic Block Storage 저장 공간이 생성되어지며 EC2에 부착된다. 디스크 볼륨 위에 File System이 생성된다. EBS는 특정 Availability Zone(AZ)에 생성된다. 일종의 Disaster Recovery 리전내 다른 AZ로 복사된다. EBS 볼륨 타입 ELB 인스턴스가 셧다운되거나 시간초과 같은 현상이 발생했을때 적절히 다른곳으로 흘려보내줌. ELB 종류 커스터마이징을 통해 특정서버로 Request를 보낼 수 있다. 레이어4는 Transport이며, TCP의 트래픽을 정리하는데 적합함. EC2는 Private IP address만 볼수 있음!! 따라서 출처가 어디인지 어디서 흘러들어 왔는지 전혀 알 수 없다. 하지만 X-Forwarded-For 헤더를 통해 어떤 public IP 주소를 통해서 왔는지 알 수 있다. ","permalink":"https://92SooJong.github.io/posts/aws/%EA%B8%B0%EB%B3%B8%EA%B0%95%EC%9D%98%ED%95%84%EA%B8%B0/","summary":"개요 Amazon Web Service 클라우드 컴퓨팅 서버리스(Serverless) 기능 지원 클라우드가 서버를 작동하고 메모리 할당을 효율적으로 수행함. 계정 만들기 사용하는 만큼 비용 지불 (As You Pay Go) Free-tier는 일종의 데모버전 ( 무료 ) 루트(Root) 사용자. 전지전능한 사용자. 권한부여나 다른 사용자를 만듦. IAM이란? IAM은 Identity and Access Management의 약자이다. 유저를 관리하고 접근 레벨 및 권한에 대한 관리를 해준다. 다른 유저를 생성할 수 있는데 유저에 대한 접근키와 비밀키를 제공한다. 접근키는 user_id , 비밀키는 password라고 생각하면 된다.","title":"강의필기"},{"content":"제네릭의 기본인 1.1~1.3은 생략함\n1.4 제한된 지네릭 클래스 다음과 같이 작성하면 Fruit의 자손타입만 T에 대입할 수 있다. (= Fruit를 implements 또는 extends한 클래스만 T에 대입할 수 있다.) 좀 더 엄격하게 FruitBox에 들어올 수 있는 타입을 관리할 수 있다.\n1class FruitBox\u0026lt;T extends Fruit\u0026gt;{ 2\tArrayList\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); 3\t... 4} Fruit의 자손 인스턴스는 얼마든지 담을 수 있다. 다형성을 이용해 여러 과일을 담을 수 있게 되었다.\n1FruitBox\u0026lt;Fruit\u0026gt; fruitBox = new FruitBox\u0026lt;Fruit\u0026gt;(); 2fruitBox.add(new Apple()); // Apple이 Fruit의 자손 3fruitBox.add(new Grape()); // Grape는 Fruit의 자손 클래스가 아닌 인터페이스를 구현해야하는 경우 아래와 같이 작성하면 된다. 주의할 점은 implements 키워드 대신에 extends를 사용한다는 점이다.\n1interface Eatable {} 2class FruitBox\u0026lt;T extends Eatable\u0026gt; {...} Fruit의 자손이면서 Eatable 인터페이스도 구현해야 하는 경우 아래와 같이 작성한다.\n1class Fruit\u0026lt;T extends Fruit \u0026amp; Eatable\u0026gt; {...} FruitBox에는 Fruit의 자손이면서 Eatable을 구현한 클래스만 타입 매개변수 T에 대입될 수 있다.\n1import java.util.ArrayList; 2 3interface Eatable { } 4 5class Fruit implements Eatable{ 6 public String toString(){ return \u0026#34;Fruit\u0026#34;;} 7} 8 9class Apple extends Fruit { public String toString() { return \u0026#34;Apple\u0026#34;;}} 10class Grape extends Fruit { public String toString() { return \u0026#34;Grape\u0026#34;;}} 11class Toy { public String toString() { return \u0026#34;Toy\u0026#34;;}} 12 13public class App { 14 public static void main(String[] args) { 15 FruitBox\u0026lt;Fruit\u0026gt; fruitBox = new FruitBox\u0026lt;\u0026gt;(); 16 FruitBox\u0026lt;Apple\u0026gt; appleBox = new FruitBox\u0026lt;\u0026gt;(); 17 FruitBox\u0026lt;Grape\u0026gt; grapeBox = new FruitBox\u0026lt;\u0026gt;(); 18 //FruitBox\u0026lt;Grape\u0026gt; grapeBox = new FruitBox\u0026lt;Apple\u0026gt;();//에러. 타입불일치 19 //FruitBox\u0026lt;Toy\u0026gt; toyBox = new FruitBox\u0026lt;Toy\u0026gt;(); //에러. 제네릭을 지원하지 않음. 20 21 fruitBox.add(new Fruit()); 22 fruitBox.add(new Apple()); 23 fruitBox.add(new Grape()); 24 appleBox.add(new Apple()); 25 //appleBox.add(new Grape()); // 에러. Grape는 Apple의 자손이 아니다. 26 grapeBox.add(new Grape()); 27 28 System.out.println(\u0026#34;fruitBox = \u0026#34; + fruitBox); 29 System.out.println(\u0026#34;appleBox = \u0026#34; + appleBox); 30 System.out.println(\u0026#34;grapeBox = \u0026#34; + grapeBox); 31 32 } 33 34} 35 36class Box\u0026lt;T\u0026gt;{ 37 ArrayList\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); 38 void add(T item){ list.add(item);} 39 T get(int i){return list.get(i);} 40 int size(){return list.size();} 41 public String toString(){return list.toString();} 42} 43 44class FruitBox\u0026lt;T extends Fruit \u0026amp; Eatable\u0026gt; extends Box\u0026lt;T\u0026gt;{ 45} 1.5 와일드 카드 FruitBox의 내용물을 통해 Juice 인스턴스를 반환하는 Juicer 클래스의 스태틱 메소드.\n여기서 makeJuice의 파라미터인 FruitBox의 타입 매개변수가 Fruit 임에 주목한다.\n1class Juicer{ 2\tstatic Juice makeJuice(FruitBox\u0026lt;Fruit\u0026gt; box){ 3\tString tmp = \u0026#34;\u0026#34;; 4\tfor(Fruit f : box.getList()) tmp += f + \u0026#34; \u0026#34;; 5\treturn new Juice(tmp); 6\t} 7} static 메소드는 타입 매개변수를 사용할 수 없으므로 아예 지네릭스를 적용하지 않던지 위처럼 특정 타입 매개변수를 지정해 줘야한다.\n1FruitBox\u0026lt;Fruit\u0026gt; fruitBox = new FruitBox\u0026lt;\u0026gt;(); 2FruitBox\u0026lt;Apple\u0026gt; appleBox = new FruitBox\u0026lt;\u0026gt;(); 3... 4 5System.out.println(Juicer.makeJuice(fruitBox)); 6System.out.println(Juicer.makeJuice(appleBox)); // 에러. 이 문제를 해결하기 위한 가장 단순한 방법은 makeJuice를 매개변수 타입별로 여러개 만드는 것이지만, 자바 컴파일에선 지네릭 타입이 다른 것만으로 오버로딩이 성립하지 않는다고 인식하기 때문에 에러가 발생한다. 즉, 오버로딩이 아닌 메소드 중복이 발생한다. 이 문제를 해결하기 위해 고안된 것이 와일드 카드이다.\n와일드 카드는 아래의 문법을 따른다.\n\u0026lt;? extends T\u0026gt; 는 와일드 카드의 상한 제한. T와 그 자손들만 가능하다.\n\u0026lt;? super T\u0026gt; 는 와일드 카드의 하한 제한. T와 그 조상들만 가능하다.\n\u0026lt;?\u0026gt;는 제한없음. 모든 타입이 가능. \u0026lt;? extends Object\u0026gt;와 동일하게 동작한다.\n와일드 카드를 사용해 makeJuice()의 매개변수 타입을 변경해보자.\n1class Juicer{ 2\t// FruitBox에는 타입 매개변수로 Fruit와 그 자손들만 올 수 있다. 3\tstatic Juice makeJuice(FruitBox\u0026lt;? extends Fruit\u0026gt; box){ 4\tString tmp = \u0026#34;\u0026#34;; 5\tfor(Fruit f : box.getList()) tmp += f + \u0026#34; \u0026#34;; 6\treturn new Juice(tmp); 7\t} 8} ","permalink":"https://92SooJong.github.io/posts/java/java-standard/generic/","summary":"제네릭의 기본인 1.1~1.3은 생략함\n1.4 제한된 지네릭 클래스 다음과 같이 작성하면 Fruit의 자손타입만 T에 대입할 수 있다. (= Fruit를 implements 또는 extends한 클래스만 T에 대입할 수 있다.) 좀 더 엄격하게 FruitBox에 들어올 수 있는 타입을 관리할 수 있다.\n1class FruitBox\u0026lt;T extends Fruit\u0026gt;{ 2\tArrayList\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); 3\t... 4} Fruit의 자손 인스턴스는 얼마든지 담을 수 있다. 다형성을 이용해 여러 과일을 담을 수 있게 되었다.\n1FruitBox\u0026lt;Fruit\u0026gt; fruitBox = new FruitBox\u0026lt;Fruit\u0026gt;(); 2fruitBox.","title":"Generic"},{"content":"LocalDateTime java.base 모듈에 있는 java.time 패키지를 확인하면 시간과 관련된 클래스를 확인할 수 있다.\n정의 LocalDateTime은 Time-zone개념이 없는 ISO-8601 달력 시스템을 따라 만들어졌다. Time-zone은 특정 지역을 대표하는 시간을 의미한다. 2007-12-03T10:15:30 과 같이 표기할 수 있다. 시간은 나노세컨드까지 표기가 가능하다. 2nd October 2007 at 13:45.30.123456789 불변객체다. 즉, 한번 인스턴스화 되면 값을 변경할 수 없다. year-month-day-hour-minute-second 형태로 주로 표현한다. 이 클래스는 time-zone을 저장하거나 나타내지 않는다. 로컬 타임 기준으로 생일과 같은 특정 날짜를 표기하기 위해 사용한다. (지역설정 불가능. 로컬 시간만 나타낼 수 있음) offset이나 time-zone과 같이 추가적인 정보가 없으면 특정 타임라인에 대한 시간을 나타낼 수 없다. ISO-8601 달력 시스템은 현대에서 가장 많이 사용되고 있으며 윤년 규칙이 적용되어 있는 그레고리안 캘린더 시스템을 따른다. 과거의 날짜를 만들거나 아주 정확한 시간을 요구하는 경우에는 ISO-8601을 사용을 추천하지 않는다. 비교를 수행할땐 equals 메소드를 통해서 하도록 하자. 필드 LocalDate와 LocalTime으로 이뤄져있다. 메소드 현재 시간을 구할때는 now 메소드를 사용한다. now는 ZoneId, Clock 객체를 통해 구한다. of 메소드를 통해서 LocalDateTime 인스턴스를 생성한다. of도 now처럼 오버라이딩 방식으로 여러개 작성되어 있다. Month가 Enum Type이다. 숫자로도 입력가능하도록 of 메소드가 구현되어 있음 ofInstant 메소드를 통해서도 LocalDateTime을 구할 수 있다. Instant는 즉각적인 시간을 나타내는 시간 타입이다. 주로 애플리케이션에서 이벤트가 발생한 시간을 기록할때 사용한다. ZoneId 는 지역을 의미하며 ZoneRules 는 지역의 오프셋을 어떻게 관리할지에 대한 정보가 기록되어 있다. 대한 ZoneOffset은 Greenwich/UTC 시간으로 부터의 오프셋을 나타낸다. ofEpochSecond 메소드는 일반적인 앱에선 사용할일은 없고, low-level 수준의 변환이 필요할때 쓴다. epochSecond는 1970-01-01T00:00:00Z 로 부터의 초를 의미한다. TemporalAccessor 를 통해 인스턴스를 생성한다.\n명확하지 않은 date,time 정보를 분석해 LocalDateTime 인스턴스로 반환\nCharSequence 타입(주로 String)의 텍스트를 입력으로 받아 LocalDateTime 인스턴스를 반환한다.\n파싱을 위해 DateTimeFormatter 를 사용한다\n복사본 인스턴스를 만들어서 반환한다. 파라미터로 들어온 새로운 날짜와 시간이 현재 인스턴스가 가진 값과 같으면 복사를 진행하지 않는다.\n","permalink":"https://92SooJong.github.io/posts/java/localdatetime/","summary":"LocalDateTime java.base 모듈에 있는 java.time 패키지를 확인하면 시간과 관련된 클래스를 확인할 수 있다.\n정의 LocalDateTime은 Time-zone개념이 없는 ISO-8601 달력 시스템을 따라 만들어졌다. Time-zone은 특정 지역을 대표하는 시간을 의미한다. 2007-12-03T10:15:30 과 같이 표기할 수 있다. 시간은 나노세컨드까지 표기가 가능하다. 2nd October 2007 at 13:45.30.123456789 불변객체다. 즉, 한번 인스턴스화 되면 값을 변경할 수 없다. year-month-day-hour-minute-second 형태로 주로 표현한다. 이 클래스는 time-zone을 저장하거나 나타내지 않는다. 로컬 타임 기준으로 생일과 같은 특정 날짜를 표기하기 위해 사용한다.","title":"LocalDateTime"},{"content":"7.3 복합 키와 식별 관계 매핑 7.3.1 식별 관계 vs 비식별 관계 식별관계 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용한다. 비식별 관계 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다. 필수적 비식별 관계(Mandatory) 외래 키에 NULL을 허용하지 않는다. 반드시 연관관계를 맺어야 한다. 선택적 비식별 관계(Optional) 외래 키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다. 최근 트렌드는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다. 7.3.2 복합 키: 비식별 관계 매핑 둘 이상의 컬럼으로 구성된 복합 키는 별도의 식별 클래스를 정의해야한다. 식별자를 구분하기 위해서 equals 와 hashcode 메소드를 통해서 동등성을 비교한다. 식별자 필드가 1개일때는 자바에서 제공하는 타입을 사용하기 때문에 직접 equals 와 hashcode 를 사용할 필요가 없으나, 직접 식별 클래스를 정의할때는 equals 와 hashcode 를 직접 작성 해줘야한다. JPA는 복합키를 위해 @EmbeddedId 와 @IdClass 를 제공한다. @IdClass 는 데이터베이스에 맞춘 방법이고, @EmbeddedId 는 좀 더 객체지향적인 방법이다. @IdClass 아래와 같이 복합키 클래스를 작성한다. Serializable 인터페이스를 구현해야한다. equals 와 hashCode 를 작성해야한다. 기본 생성자가 있어야한다. 식별자 클래스는 public이어야 한다. 아래와 같이 ParentId 클래스를 이용하는 Entity를 생성한다. 주의할 점은 Parent 클래스의 식별자 필드명이 ParentId 의 필드명과 같아야 한다. 간단한 예제를 살펴보자. Parent 엔티티를 저장할때 ParentId를 전혀 사용하지 않는 모습을 확인할 수 있다. Parent 엔티티를 persist 하게되면 내부적으로 ParentId를 만들어서 영속성 컨텍스트의 엔티티 키로 사용한다. 1Parent parent = new Parent(); 2parent.setId1(\u0026#34;myId1\u0026#34;); 3parent.setId2(\u0026#34;myId2\u0026#34;); 4parent.setName(\u0026#34;soojong\u0026#34;); 5em.persist(parent); 6 7ParentId parentId = new ParentId(\u0026#34;myId1\u0026#34;, \u0026#34;myId2\u0026#34;); 8Parent findParent = em.find(Parent.class, parentId); 9 10System.out.println(\u0026#34;findParent.getId1() = \u0026#34; + findParent.getId1()); 11System.out.println(\u0026#34;findParent.getId2() = \u0026#34; + findParent.getId2()); 12System.out.println(\u0026#34;findParent.getName() = \u0026#34; + findParent.getName()); Child Entity를 정의해보자. Parent와 연관관계를 맺으려고 하는데 Parent 클래스의 PK가 2개인 경우 아래와 같이 @JoinColumns 어노테이션을 사용하면 된다. @EmbeddedId ParentId 클래스를 아래와 같이 작성한다. @IdClass 방식과 달리 ParentId에 직접 기본키 컬럼명을 작성한다. 마찬가지로 몇가지 지켜야할 사항이 있는데 아래와 같다. Serializable 인터페이스를 구현해야한다. equals 와 hashCode 를 구현해야한다. 기본 생성자가 있어야한다. 식별자 클래스는 public 이어야한다. Parent 엔티티가 덕분에 심플해진다. 사용 예제를 살펴보자. 이전과 달리 직접 ParentId를 정의하고 세팅해줘야한다. 1Parent parent = new Parent(); 2ParentId parentId = new ParentId(\u0026#34;myId1\u0026#34;, \u0026#34;myId2\u0026#34;); 3parent.setId(parentId); // 직접 세팅 4parent.setName(\u0026#34;parentName\u0026#34;); 5em.persist(parent); 6 7ParentId findParentId = new ParentId(\u0026#34;myId1\u0026#34;, \u0026#34;myId2\u0026#34;); 8Parent findParent = em.find(Parent.class, findParentId); 9 10System.out.println(\u0026#34;findParent.getName() = \u0026#34; + findParent.getName()); 복합 키와 equals(), hashCode() 복합키를 사용하는 경우 직접 equals 와 hashCode 메소드를 구현해야한다. Object가 제공하는 equals 의 내부 동작 방식은 참조값 비교인 == (동일성) 비교 이다. 영속성 컨텍스트에 있는 엔티티의 키를 찾을때는 equals를 수행하는데 복합키 클래스를 참조 비교하지 않도록 재작성 해야한다. (동등성 비교를 수행하도록 수정 필요) 따라서 복합키 클래스는 equals 메소드를 적절히 오버라이딩해서 작성해야한다. 1ParentId id1 = new ParentId(\u0026#34;myId1\u0026#34;,\u0026#34;myId2\u0026#34;); 2ParentId id2 = new ParentId(\u0026#34;myId1\u0026#34;,\u0026#34;myId2\u0026#34;); 3 4System.out.println(\u0026#34;id1.equals(id2) = \u0026#34; + id1.equals(id2)); 5System.out.println(\u0026#34;id1.hashCode() = \u0026#34; + id1.hashCode()); 6System.out.println(\u0026#34;id2.hashCode() = \u0026#34; + id2.hashCode()); @IdClass vs @EmbeddedId 두개의 방식이 각각 장단점이 있기때문에 본인의 취향에 맞는 것을 일관성 있게 사용하면된다. 7.3.3 복합 키: 식별 관계 매핑 @IdClass 방식 아래 그림은 부모에서부터 자식,손자까지 기본 키를 전달하는 식별관계를 나타낸다. 아래 관계를 @IdClass 와 @EmbeddedId 를 사용해서 작성해본다. 먼저 PARENT 테이블에 대응되는 Parent Entity를 정의한다. 다음 CHLID 테이블에 대응되는 Child Entity를 정의한다. CHILD 테이블은 복합키를 가지며, 그중 PARENT_ID는 PARENT 테이블에서 가져온다. JPA에선 아래와 같이 작성한다. Child Entity가 복합키를 갖도록 ChildId 클래스를 정의한다. 필드명은 Child Entity의 필드명을 그대로 작성해준다. 데이터 타입은 실제 Id의 타입을 따르도록 작성한다. ( Parent Entity의 키 타입을 따르도록한다.) GRANDCHILD 테이블에 대응되는 GrandChild Entity를 작성한다. 물리적으로 총 3개의 키를 가지는 복합키이다. 복합키와 연관관계를 맺을 수 있도록 아래와 같이 작성한다. 복합키를 사용할 수 있도록 GrandChildId 클래스를 정의한다. 마찬가지로 데이터 타입은 Child Entity의 데이터 타입을 따르도록 작성한다. 필드명은 GrandChild Entity에 정의되어 있는 키 필드와 동일하게 작성한다. @EmbeddedId 방식 @EmbeddedId 방식을 사용해서 식별 관계 매핑을 구성할때는 @MapsId 를 사용해야 한다. Parent Entity를 작성한다. Chlid Entity를 작성한다. @MapsId 어노테이션을 통해 ChildId 클래스에 존재하는 parentId와 매핑을 수행한다. ChildId 클래스를 작성한다. @MapsId(\u0026quot;parentId\u0026quot;) 어노테이션과 매핑 될수 있도록 필드명을 parentId로 작성한다. GrandChild Entity를 작성한다. GrandChildId 클래스를 작성한다. @MapsId(\u0026quot;childId\u0026quot;) 와 매핑하기 위해 필드명을 childId로 해야한다. 7.3.4 비식별 관계로 구현 7.3.3에서 사용한 식별 관계를 비식별 관계로 변형해서 구현해본다. Parent Entity를 작성한다. Child Entity를 작성한다. GrandChild Entity를 작성한다. 식별 관계의 복합키를 가지는 경우에 비해 코드가 단순해졌다. 7.3.5 일대일 식별 관계 일대일 식별 관계를 가지는 케이스를 살펴보자. 먼저 Board 테이블에 대응되는 Board Entity를 만든다. BoardDetail Entity를 가져올 수 있도록 연관관계를 매핑한다. BoardDetail 테이블에 대응되는 BoardDetail Entity를 만든다. 특이한 점이 있는데 Board Entity의 Key를 그대로 사용하는것이기 때문에 boardId 필드에 @GeneratedValue 어노테이션이 없다. BoardDetail에는 식별자가 단 1개만 존재하기 때문에 @MapsId 에 별도의 파라미터를 쓰지 않아도 된다. 이렇게 작성하면 유일한 key 필드인 boardId에 자동으로 매핑되어 정보를 가져올 수 있게된다. 7.3.6 식별, 비식별 관계의 장단점 식별 관계보다는 비식별 관계를 선호한다. 아주 특별한 경우가 아니라면 비식별 관계를 사용하고, 기본 키는 Long 타입의 대리 키를 사용하는 것이 좋다. Long 타입을 추천하는 이유는 자바에서 Integer는 20억 정도면 끝나버리지만, Long 타입은 290경까지 표기가 가능하다. 선택적 비식별 관계보단 필수적 비식별 관계를 사용하는 것이 좋다. 선택적인 비식별 관계는 NULL을 허용하기 때문에 Join시에 외부(Outter) Join을 사용해야한다. 반면에 필수적 비식별 관계는 NOT NULL이기 때문에 항상 관계가 있다는 것을 보장하므로 내부(Inner) Join만 사용해도 된다. 데이터베이스 설계 관점 - 비식별 선호 부모 테이블의 키를 자식 테이블로 전파하면서 자식 테이블의 키가 늘어나는 현상이 있다. 예시) 부모는 키 1개, 자식은 키 2개, 손자는 키 3개 이렇게 되면 Join시에 SQL이 복잡해지고, 인덱스의 사이즈가 커진다. 복합키를 구성할때 주로 비즈니스와 관련된 컬럼을 사용하는데 비즈니스 변경시에 테이블 작업량이 커진다. 키를 다른 테이블에서 참조하고 있기때문에 테이블 구조가 유연하지 못하게된다. 객체 관계 매핑 관점 - 비식별 선호 복합키를 사용하면 별도의 복합키 클래스를 만들어야 하기 때문에 작업량이 늘어난다. 비식별 관계의 기본 키는 주로 대리키를 사용하며 이와 관련된 @GeneratedValue 를 JPA에서 기본적으로 제공한다. (편리성 증가) 식별 관계가 가지는 미세한(?) 장점 식별 관계를 사용하면 키본 키 인덱스를 활용하기 좋다. 상우 테이블의 키를 자식이 가지고 있으므로, 특정 상황에서 Join을 사용하지 않고 하위테이블 만으로 검색이 가능하다. 예시) 부모의 ID가 A인 자식을 모두 조회하는 경우 자식 테이블 만으로 검색이 가능하다. ","permalink":"https://92SooJong.github.io/posts/jpa/book-1/7-3-%EB%B3%B5%ED%95%A9-%ED%82%A4%EC%99%80-%EC%8B%9D%EB%B3%84-%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/","summary":"7.3 복합 키와 식별 관계 매핑 7.3.1 식별 관계 vs 비식별 관계 식별관계 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용한다. 비식별 관계 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다. 필수적 비식별 관계(Mandatory) 외래 키에 NULL을 허용하지 않는다. 반드시 연관관계를 맺어야 한다. 선택적 비식별 관계(Optional) 외래 키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다. 최근 트렌드는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다.","title":"7.3 복합 키와 식별 관계 매핑"},{"content":"7.2 @MappedSuperClass 7.1에서 본 전략은 부모 클래스가 실제 물리 테이블과 매핑되어 있어야 한다. @MappedSuperClass 를 사용하면 부모 클래스는 물리 테이블과 매핑하지 않고 부모 클래스를 상속받은 자식만 물리 테이블로 생성할 수 있다. 2개의 자식 클래스가 BaseEntity를 상속받는다. 물리테이블은 아래와 같이 2개만 생성된다. ","permalink":"https://92SooJong.github.io/posts/jpa/book-1/7-2-mappedsuperclass/","summary":"7.2 @MappedSuperClass 7.1에서 본 전략은 부모 클래스가 실제 물리 테이블과 매핑되어 있어야 한다. @MappedSuperClass 를 사용하면 부모 클래스는 물리 테이블과 매핑하지 않고 부모 클래스를 상속받은 자식만 물리 테이블로 생성할 수 있다. 2개의 자식 클래스가 BaseEntity를 상속받는다. 물리테이블은 아래와 같이 2개만 생성된다. ","title":"7.2 @MappedSuperClass"},{"content":"7.1 상속 관계 매핑 조인 전략 슈퍼타입 역할을 할 엔티티를 만든다. @Inheritance 어노테이션을 통해서 매핑전략을 지정할 수 있다. 현재 예시에선 조인 전략을 사용하므로 InheritanceType.JOINED 로 전략을 지정한다. @DiscriminatorColumn 어노테이션을 통해서 자식 엔티티를 구분하기 위한 컬럼을 생성한다. 자식 엔티티는 부모 엔티티인 Item을 상속한다. @DiscriminatorValue 어노테이션을 통해 엔터티 구분을 위한 코드를 지정한다. @PrimaryKeyJoinColumn 어노테이션을 통해 부모 엔터티에서 제공하는 PK명을 수정할 수 있다. 물리테이블과 컬럼은 아래와 같이 생성된다. 장점 테이블 정규화 외래 키 참조 무결성 제약조건 활용 가능 저장공간의 효율성 단점 조회시 Join을 사용하므로 성능 저하 발생가능성이 높아짐 조회 쿼리가 복잡하다. 데이터 등록시 Insert문이 두번 실행된다. 단일 테이블 전략 @Inheritance 어노테이션을 통해서 매핑전략을 지정할 수 있다. 현재 예시에선 단일 테이블 전략을 사용하므로 InheritanceType.SINGLE_TABLE 전략을 사용한다. 단일 테이블 전략이므로 이전처럼 Book 엔터티에 독립적인 PK컬럼명을 지정할 수 없다. 물리테이블은 다음과 같이 1개만 생성된다. 장점 조인이 없기때문에 조회 속도가 빠르다. 조회 쿼리가 단순하다. 단점 자식 엔터티가 매핑한 컬럼은 모두 null을 허용해야 한다. 단일 테이블에 모든 데이터를 저장하기 때문에 테이블이 커진다. 상황에따라 오히려 조회성능이 더 나빠질 수 있다. ","permalink":"https://92SooJong.github.io/posts/jpa/book-1/7-1-%EC%83%81%EC%86%8D-%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/","summary":"7.1 상속 관계 매핑 조인 전략 슈퍼타입 역할을 할 엔티티를 만든다. @Inheritance 어노테이션을 통해서 매핑전략을 지정할 수 있다. 현재 예시에선 조인 전략을 사용하므로 InheritanceType.JOINED 로 전략을 지정한다. @DiscriminatorColumn 어노테이션을 통해서 자식 엔티티를 구분하기 위한 컬럼을 생성한다. 자식 엔티티는 부모 엔티티인 Item을 상속한다. @DiscriminatorValue 어노테이션을 통해 엔터티 구분을 위한 코드를 지정한다. @PrimaryKeyJoinColumn 어노테이션을 통해 부모 엔터티에서 제공하는 PK명을 수정할 수 있다. 물리테이블과 컬럼은 아래와 같이 생성된다. 장점 테이블 정규화 외래 키 참조 무결성 제약조건 활용 가능 저장공간의 효율성 단점 조회시 Join을 사용하므로 성능 저하 발생가능성이 높아짐 조회 쿼리가 복잡하다.","title":"7.1 상속 관계 매핑"},{"content":"4.3.1 도커 컴포즈 기본 사용법 도커 컴포즈는 컨테이너의 설정이 정의된 YAML 파일을 읽어서 컨테이너를 생성한다. 아래와 같이 docker-compose.yml 파일을 작성한다. version 은 YAML파일의 포맷버전을 의미한다. services 생성될 컨테이너를 묶는 단위를 의미한다. web mysql 생성될 서비스의 이름이다. 해당 항목 아래에 컨테이너가 생성될 때 필요한 옵션을 지정할 수 있다. 1version: \u0026#39;3.0\u0026#39; 2services: 3 web: 4 image: alicek106/composetest:web 5 ports: 6 - \u0026#34;80:80\u0026#34; 7 links: 8 - mysql:db 9 command: sh -c \u0026#39;echo \u0026#34;ServerName localhost\u0026#34; \u0026gt;\u0026gt; /etc/apache2/apache2.conf \u0026amp;\u0026amp; cat /etc/apache2/apache2.conf \u0026amp;\u0026amp; apachectl -D FOREGROUND\u0026#39; 10 mysql: 11 image: alicek106/composetest:mysql 12 command: mysqld docker-compose up -d 명령어를 통해 컨테이너를 생성한다. 교재대로 하면 apache 서버가 실행되지 않았다. 위처럼 직접 ServerName을 localhost로 지정해주니 정상적으로 실행이 됐다. 정상적으로 2개의 컨테이너가 생성되었다. docker ps --format \u0026quot;table {{.Names}}\\t{{.Image}}\\t{{.Ports}}\u0026quot; 를 통해 조회해본다. 컨테이너 이름은 [프로젝트 이름]_[서비스 이름]_[서비스내 컨테이너 번호] 로 자동 생성된다. 프로젝트 이름을 따로 지정하지 않는다면 docker-compose.yml 파일이 존재하던 디렉터리 명이 프로젝트 이름이 된다. 정상적으로 서비스하는 사이트에 접속이 된다. 서비스 내에는 여러개의 컨테이너가 존재할 수 있으며, replication을 지원한다. docker-compose scale [서비스명]=[개수] 명령어를 통해 특정 서비스를 복사할 수 있다. 이유는 모르겠지만 2개중 1개의 서비스가 종료되어 버렸다. docker-compose down 명령어를 사용하면 모든 서비스를 중단하고 컨테이너를 삭제한다. -p 옵션을 통해 프로젝트 명을 지정할 수 있다. 따라서 똑같은 docker-compose.yml을 실행하더라도 분리된 운영이 가능해진다. 조회 및 삭제시에도 -p 옵션을 사용해서 프로젝트에 대한 개별적인 제어가 가능하다. 4.3.2 도커 컴포즈 활용 버전 version: '3.0' 과 같이 작성한다. 도커 컴포즈 버전 1.10에선 YAML 3.0 문법 사용이 가능하다. 서비스 정의 생성할 컨테이너의 옵션을 정의한다. 각 서비스는 컨테이너로 구현된다. image 옵션은 서비스의 컨테이너를 생성할 때 쓰일 이미지의 이름을 설정한다. 1services: 2 my_container_1: 3 image: ... 4 my_container_2: 5 image: ... links 옵션은 다른 서비스에 서비스명만으로 접근할 수 있도록 한다. 아래와 같이 작성하며, [SERVICE:ALIAS] 형태로 작성하면 별칭으로도 접근이 가능하게된다. 1services: 2 web: 3 links: 4 - db 5 - db:database 6 - redis environment 옵션은 서비스의 컨테이너 내부에서 사용할 환경변수를 지정한다. 아래와 같이 2가지 방식을 허용한다. 1services: 2 web: 3 environment: 4 - MYSQL_ROOT_PASSWORD=mypassword 5 또는 6\tenvironment: 7 - MYSQL_ROOT_PASSWORD: mypassword command 옵션은 컨테이너가 실행될 때 수행할 명령어를 설정한다. 아래와 같이 2가지 방식을 허용한다. 1services: 2 web: 3 image: alicek106/composetest:web 4 command: apachectl -DFOREGROUND 5 또는 6\timage: alicek106/composetest:web 7\tcommand: [apachectl, -DFOREGROUND] depends_on 옵션은 특정 컨테이너에 대한 의존관계를 설정한다. 이 항목에 명시된 컨테이너가 먼저 실행되고 나서 현재 컨테이너가 실행된다. 아래와 같이 작성하면 된다. 주의할 점은 순서만 보장하며, 실행이 완료되었는지는 확인하지 않는다. 1services: 2 web: 3 image: alicek106/composetest:web 4 depends_on: 5 - mysql 6 mysql: 7 image: alicek106/composetest:mysql ports 명령어는 서비스의 컨테이너를 개방할 포트를 설정한다. 호스트의 특정 포트를 서비스의 컨테이너에 연결하면 scale 명령어로 서비스의 컨테이너의 수를 늘릴수 없다. 1services: 2 web: 3 image: alicek106/composetest:web 4 ports: 5 - \u0026#34;8080\u0026#34; 6\t- \u0026#34;8081-8085\u0026#34; 7\t- \u0026#34;80:80\u0026#34; build 명령어는 Dockerfile에서 이미지를 빌드해 서비스의 컨테이너를 생성하도록 한다. build 에 정의된 dockerfile을 사용해서 image 에 정의된 이름으로 이미지를 만든다. 주의할 점은 Dockerfile을 수정해도 새로운 이미지를 생성하지 않는다. --build 옵션을 통해서 매번 이미지를 빌드할 수 있도록 할 수 있다. 1services: 2 web: 3 build: ./composetest 4 image: alicek106/composetest:web 5\t또는 6 build: ./composetest 7\tcontext: ./composetest 8\tdockerfile: myDockerfile 9\targs: 10\tHOST_NAME: web 11\tHOST_CONFIG: self_config extends 다른 YAML 파일이나 현재 YAML 파일에서 서비스 속성을 상속받게 설정한다. 아래와 같이 extends 명령어를 통해 설정을 상속 받을 수 있다. 1version: \u0026#39;3.0\u0026#39; 2\tservices: 3\tweb: 4\textends: 5\tfile: extend_compose.yml 6\tservice: extend_web extend_compose.yml 파일은 아래와 같다고 가정했다. 1version: \u0026#39;3.0\u0026#39; 2\tservices: 3\textend_web: 4\timage: ubuntu:14.04 5\tports: 6\t- \u0026#34;80:80\u0026#34; 다음과 같이 1개의 yml 파일 안에서도 extends 가 가능하다. 1version: \u0026#39;3.0\u0026#39; 2\tservices: 3\tweb: 4\textends: 5\tservice: extend_web 6\textend_web: 7\timage: ubuntu:14.04 8\tports: 9\t- \u0026#34;80:80\u0026#34; 네트워크 정의 driver 를 통해 기본으로 제공하는 브리지 타입의 네트워크가 아닌 원하는 네트워크를 사용하도록 설정할 수 있다. 아래는 overlay 방식의 네트워크를 mynetwork로 정의해서 서비스가 사용하는 예제이다. 1version: \u0026#39;3.0\u0026#39; 2\tservices: 3\tmyservice: 4\timage: nginx 5\tnetworks: 6\t- mynetwork 7networks: 8\tmynetwork: 9\tdriver: overlay 10\tdriver_opts: 11\tsubnet: \u0026#34;255.255.255.0\u0026#34; 12\tIPAdress: \u0026#34;10.0.0.2\u0026#34; ipam(IP Address Manager) 는 subnet, ip 범위 등을 설정할 수 있다. 1version: \u0026#39;3.0\u0026#39; 2\t... 3networks: 4\tipam: 5\tdriver: mydriver 6\tconfig: 7\tsubnet: 172.20.0.0/16 8\tip_range: 172.20.5.0/24 9\tgateway: 172.20.5.1 external 명령어를 통해 프로젝트를 생성할때마다 새로운 네트워크를 생성하는것이 아닌 기존의 네트워크를 사용할 수 있도록 한다. external 은 기존의 준비된 네트워크를 사용하기 때문에 drvier,driver_ops, ipam 옵션과 함께 사용이 불가능하다. 1 2services: 3\tweb: 4\timage: alicek106/composetest:web 5\tnetworks: 6\t- alicek106_network 7networks: 8\talicek106_network: 9\texternal: true 볼륨 정의 driver 명령어는 볼륨을 생성할 때 사용될 드라이버를 설정합니다. 1version: \u0026#39;3.0\u0026#39; 2services: 3\t... 4volumes: 5\tdriver: flocker 6\tdriver_opts: 7\topt: \u0026#34;1\u0026#34; 8\topt2 : 2 external 명령어를 사용하면 기존 볼륨을 사용하도록 설정할 수 있다. 1services: 2\tweb: 3\timage: alicek106/composetest:web 4\tvolumes: 5\t- myvolume:/var/www/html 6volumes: 7\tmyvolume: 8\texternal: true YAML 파일 검증하기 docker-compose config 명령어를 사용해서 YAML 파일의 오타나, 파일 포맷 등을 검사할 수 있습니다. ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/4-3-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EC%82%AC%EC%9A%A9/","summary":"4.3.1 도커 컴포즈 기본 사용법 도커 컴포즈는 컨테이너의 설정이 정의된 YAML 파일을 읽어서 컨테이너를 생성한다. 아래와 같이 docker-compose.yml 파일을 작성한다. version 은 YAML파일의 포맷버전을 의미한다. services 생성될 컨테이너를 묶는 단위를 의미한다. web mysql 생성될 서비스의 이름이다. 해당 항목 아래에 컨테이너가 생성될 때 필요한 옵션을 지정할 수 있다. 1version: \u0026#39;3.0\u0026#39; 2services: 3 web: 4 image: alicek106/composetest:web 5 ports: 6 - \u0026#34;80:80\u0026#34; 7 links: 8 - mysql:db 9 command: sh -c \u0026#39;echo \u0026#34;ServerName localhost\u0026#34; \u0026gt;\u0026gt; /etc/apache2/apache2.","title":"4.3 도커 컴포즈 사용"},{"content":"0.도커 컴포즈를 사용하는 이유 여러 개의 컨테이너가 하나의 애플리케이션으로 동작할때 컨테이너를 한번에 생성해야한다. 여러 개의 컨테이너를 하나의 서비스로 정의해 컨테이너 묶음으로 관리할 수있도록 한다. 1. 설치 현재 ubuntu 계정이 sudo 없이 docker에 접근할 수 있도록 설정한다. 1sudo usermod -aG docker ${USER} 2sudo su - 3su - ubuntu 4groups ubuntu 아래 명령어를 통해 도커 컴포즈 1.1 버전을 다운로드 받는다. 1sudo curl -L https://github.com/docker/compose/releases/download/1.11.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose docker-compose -v 명령어를 통해서 정상적으로 설치되었는지 확인한다. ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/4-2-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EC%84%A4%EC%B9%98/","summary":"0.도커 컴포즈를 사용하는 이유 여러 개의 컨테이너가 하나의 애플리케이션으로 동작할때 컨테이너를 한번에 생성해야한다. 여러 개의 컨테이너를 하나의 서비스로 정의해 컨테이너 묶음으로 관리할 수있도록 한다. 1. 설치 현재 ubuntu 계정이 sudo 없이 docker에 접근할 수 있도록 설정한다. 1sudo usermod -aG docker ${USER} 2sudo su - 3su - ubuntu 4groups ubuntu 아래 명령어를 통해 도커 컴포즈 1.1 버전을 다운로드 받는다. 1sudo curl -L https://github.com/docker/compose/releases/download/1.11.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose docker-compose -v 명령어를 통해서 정상적으로 설치되었는지 확인한다.","title":"4.2 도커 컴포즈 설치"},{"content":" docker info 명령어를 통해 도커 엔진의 스웜 모드 클러스터 정보를 확인한다. 1sudo docker info | grep Swarm 현재는 스웜 모드를 사용하지 않기 때문에 비활성화 상태이다. 3.3.2 도커 스웜 모드 클러스터 구축 아래와 같이 3개의 ubuntu 인스턴스를 만든다. docker swarm init 명령어를 통해 클러스터의 매니저를 지정한다. 1sudo docker swarm init --advertise-addr [매니저노드 IP] 워커 노드들은 매니저를 지정할때 출력되는 명령어를 통해 클러스터에 등록할 수 있다. 매니저 노드를 지정할때 제공되는 docker swarm join 명령어를 통해서 워커노드가 특정 클러스터에 합류할 수 있다. 1sudo docker swarm join \\ 2--token SWMTKN-1-1lpyxejpu56s8sdyngbekh4cze636ba3lbtrgqppor1lc6nxlr-25nigv1hhe8q33twg1d6ckfzm \\ 354.180.138.249:2377 docker node ls 명령어를 통해서 현재 클러스터에 존재하는 노드를 모두 확인할 수 있다. docker node ls 명령어는 매니저 노드에서만 실행가능하다. * 표시는 매니저 노드를 의미한다. 매니저 노드 중에서 클러스터의 리더가 선출된다. 고가용성을 보장하기 위해 매니저를 추가해야할 경우 docker swarm join-token manager 명령어를 통해 매니저 등록을 위한 명령어와 토큰 정보를 제공받을 수 있다. 보안을 위해 토큰은 주기적으로 갱신하는게 좋으며, docker swarm join-token --rotate manager 명령어를 통해 매니저 노드를 추가하기 위한 토큰을 변경할 수 있다. 클러스터에서 워커 노드를 제거하기 위해서 워커노드 접속후 docker swarm leave 명령어를 사용하면된다. 하지만 노드를 조회 해보면 단지 워커 노드가 down되었을 뿐이다. 따라서 매니저 노드에서 docker node rm [호스트명 또는 ID의 앞자리 일부] 명령어를 사용해서 워커 노드를 제거 해줘야한다. 매니저 노드를 제거하려면 docker swarm leave --force 명령어를 사용하면된다. 워커 노드를 매니저 노드로 변경하려면 docker node promote 명령어를 사용하면 된다. 매니저 노드를 워커 노드로 변경하려면 docker node demote 명령어를 사용하면 된다. 3.3.3 스웜 모드 서비스 스웜 모드에서 제어하는 단위는 컨테이너가 아닌 서비스이다. (컨테이너를 그룹한 개념)\n서비스를 제어하면 해당 서비스 내의 컨테이너에 같은 명령이 수행된다.\n따라서 서비스내에 컨테이너는 1개 이상 존재할 수 있다.\n컨테이너들은 각 워커 노드와 매니저 노드에 할당된다.\n이러한 컨테이너들을 태스크(Task)라고 부른다.\nubuntu:14.04 이미지로 서비스를 생성하고 컨테이너 수를 3으로 설정한다면, 아래와 같이 각 노드에 Replica가 생성된다.\n만약 노드중 하나가 다운된다면 총 컨테이너 레플리카 수를 맞추기 위해서 아래와 같이 같은 노드에 2개의 컨테이너가 존재하게 된다. 서비스는 롤링 업데이트 기능을 제공함으로써 다운 타임을 최소화한다. 서비스 생성해보기 서비스를 제어하는 도커 명령어는 전부 매니저 노드에서만 사용할 수 있다. docker service create 명령어를 통해 서비스를 생성할 수 있다. 서비스내의 컨테이너는 detached 모드로 동작이 가능한 이미지를 사용해야한다. 1sudo docker service create \\ 2ubuntu:14.04 \\ 3/bin/sh -c \u0026#34;while true; do echo hello world; sleep 1; done\u0026#34; docker service ls 명령어를 통해 클러스터 내의 서비스 목록을 확인할 수 있다. docker service ps [서비스 이름] 을 통해 서비스의 자세한 내용을 확인할 수 있다. docker service rm [서비스 이름] 을 통해서 서비스를 삭제할 수 있다. nginx 웹 서버 서비스 생성하기 아래 명령어를 통해 2개의 replica를 가지는 nginx 서비스를 생성한다. 1sudo docker service create --name myweb \\ 2--replicas 2 \\ 3-p 80:80 \\ 4nginx manager 노드와 worker1 노드에 위에서 생성한 서비스가 구동중인걸 확인할 수 있다. docker service scale [서비스명]=[replica 개수] 명령어를 통해 서비스 replica 개수를 수정할 수있다. 글로벌 모드 --mode global 를 사용하면 replica를 지정하지 않아도 모든 노드에 1개의 서비스가 실행된다. 1sudo docker service create --name global_web \\ 2--mode global \\ 3nginx 각 노드별로 1개의 global_web 서비스가 실행된것을 확인할 수 있다. ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-3-%EC%8A%A4%EC%9B%9C%EB%AA%A8%EB%93%9C/","summary":"docker info 명령어를 통해 도커 엔진의 스웜 모드 클러스터 정보를 확인한다. 1sudo docker info | grep Swarm 현재는 스웜 모드를 사용하지 않기 때문에 비활성화 상태이다. 3.3.2 도커 스웜 모드 클러스터 구축 아래와 같이 3개의 ubuntu 인스턴스를 만든다. docker swarm init 명령어를 통해 클러스터의 매니저를 지정한다. 1sudo docker swarm init --advertise-addr [매니저노드 IP] 워커 노드들은 매니저를 지정할때 출력되는 명령어를 통해 클러스터에 등록할 수 있다. 매니저 노드를 지정할때 제공되는 docker swarm join 명령어를 통해서 워커노드가 특정 클러스터에 합류할 수 있다.","title":"3.3 스웜모드"},{"content":"16.1 트랜잭션과 락 16.1.1 트랜잭션과 격리 수준 트랜잭션은 기본적으로 ACID중 원자성, 일관성, 지속성은 만족한다. 여기서 다루기 피곤한 녀석이 격리성이다. 단순히 트랜잭션 간에 간섭이 없도록 격리성을 분리해버리면 테이블 접근이 제한적이기때문에 동시성 처리 성능이 떨어지게된다.\n격리수준(Isolation Level) 동시성 처리를 위해서 대부분의 Database는 READ COMMITED를 기본으로한다\nREAD UNCOMMITTED 커밋하지 않은 데이터를 읽을 수 있다. 트랜잭션1이 데이터를 변경하는 로직을 수행하더라도 트랜잭션2는 데이터를 읽을수 있다. 이를 DIRTY READ라 한다. READ COMMITED 커밋한 데이터만 읽을 수 있다. 트랜잭션1이 회원A를 조회중일때, 트랜잭션2가 회원A 정보를 수정하고 커밋을 하면 트랜잭션 1이 다시 회원 A를 조회했을때 수정된 데이터가 조회된다. 하나의 트랜잭션에서 같은 회원A 정보를 읽지 못하는 현상이 발생하게된다. 이를 NON-REPEATABLE READ라 한다. REPEATABLE READ 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 트랜잭션 1이 10살 이하의 회원을 조회했는데 트랜잭션 2가 5살 회원을 추가하고 커밋하면 트랜잭션1이 다시 10살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다. 이처럼 반복 조회시 결과 집합(개수)가 달라지는 것을 PHANTOM READ라고한다. SERIALIZABLE 가장 엄격한 트랜잭션 격리 수준이다. PHANTOM READ가 발생하지 않으나 동시성 처리 성능이 급격히 떨어진다. 16.1.2 낙관적 락과 비관적 락 기초 JPA의 영속성 컨텍스트(1차 캐시)를 적절히 활용하면 데이터베이스 트랜잭션이 READ COMMITTED 격리 수준이어도 애플리케이션 레벨에서 반복 가능한 읽기가 가능하다. (엔티티가 아닌 스칼라 값을 읽는 경우는 예외.) JPA는 데이터베이스 트랜잭션 격리 수준을 READ COMMITTED 정도로 가정한다. 일부 로직에 더 높은 격리 수준이 필요하다면 낙관적 락과 비관적 락 중 하나를 사용하면 된다. 낙관적 락 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법이다. 데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다. 낙관적 락은 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다. 비관적 락 트랜잭션의 충돌이 발생하낟고 가정하고 우선 락을 걸고 보는 방법이다. 이것은 데이터베이스가 제공하는 락 기능을 사용한다. 대표적으로 select for update 구문이 있다. 두 번의 갱신 분실 문제(second lost updates problem) A와 B가 공지사항의 내용을 수정하는 경우 A가 수정후 Commit을 했다. 이후 B가 Commit을 한다면 A의 내용은 무시된다. 이 문제를 해결하는 3가지 방법은 아래와 같다. 마지막 커밋만 인정하기 최초 커밋만 인정하기 충돌하는 갱신 내용 병합하기 기본값은 마지막 커밋만 인정하기이다. JPA가 제공하는 버전 관리 기능을 사용하면 손쉽게 최초 커밋만 인정하기를 구현할 수 있다. 16.1.3 @Version @Version 어노테이션은 Long, Integer, Short, Timestap 타입에만 적용이 가능하다.\n버전 관리 기능을 사용하기 위해서 버전 관리용 필드를 추가해야한다.\n엔티티를 수정할 때 마다 버전이 하나씩 자동으로 증가한다.\n엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다.\n아래와 같이 트랜잭션 A에서 board의 버전이 변경되는 경우 예외가 발생한다.\n트랜잭션2에 의해 테이블의 version은 2로 변경되었다. 트랜잭션이 1이 테이블에 저장하려고 할때 version이 1이기 때문에 예외가 발생한다.\n버전 정보를 사용하면 최초 커밋만 인정하기가 적용된다.\n1 // 트랜잭션 1조회 title=\u0026#34;제목A\u0026#34;, version=1 2 Board board = em.find(Board.class,id); 3 4 // 트랜잭션 2에서 해당 게시글이 수정되었다. 5 // title = \u0026#34;제목C\u0026#34; , version=2로 변경 6 7 board.setTitle(\u0026#34;제목B\u0026#34;); // 트랜잭션1 데이터 수정 8 9 save(board); 10 tx.commit(); // 예외 발생, 데이터베이스 version=2, 엔티티 version=1 16.1.4 JPA 락 사용 JPA를 사용할때 추천하는 방법은 READ COMMITTED 트랜잭션 격리 수전 + 낙관적 버전 관리이다. em.find(Board.class, id, LockModeType.OPTIMISTIC); 과 같은 형태로 Lock을 걸 수 있다. 아래와 같은 방법도 사용가능하다. 1Board board = em.find(Board.class,id); 2... 3em.lock(board, LockModeType.OPTIMISTIC); 16.1.5 JPA 낙관적 락 JPA가 제공하는 낙관적 락은 @Version을 사용한다 낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다는 특징이 있다. NONE 락 옵션을 적용하지 않아도 엔티티에 @Version 이 적용된 필드만 있으면 낙관적 락이 적용된다. 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경(삭제)되지 않도록 하기 위해서 사용한다. 조회 시점부터 수정 시점까지를 보장한다. 엔티티를 수정할 때 버전을 체크하면서 버전을 증가시킨다.(자동으로 Update 쿼리가 날라감) 두 번의 갱실 분실 문제를 예방한다. OPTIMISTIC 엔티티를 조회만 해도 버전을 체크한다. NONE은 안정적 수정을 보장, OPTIMISTIC은 안정적 조회를 보장 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다. 조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜잭션에 의해 변경되지 않아야 한다. 트랜잭션을 커밋할때 버전 정보를 조회해서 현재 엔티티의 버전과 같은지 확인한다. (버전 조회를 위한 SELECT 쿼리문 실행) OPTIMISTIC 옵션은 DIRTY READ와 NON-REPEATABLE READ를 방지한다. OPTIMISTIC_FORCE_INCREMENT 낙관적 락을 사용하면서 버전 정보를 강제로 증가시킨다. 게시물과 첨부파일 엔티티가 일대다 관계를 가지는 경우, 첨부파일 엔티티 정보만 변경하면 첨부파일 엔티티의 버전만 올라가게 된다. 이때 게시물 엔티티의 버전을 강제로 증가시키키 위해 OPTIMISTIC_FORCE_INCREMENT를 사용한다. 엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가 시킨다. 조회후 추가로 엔티티를 수정하게 된다면 버전은 2가 증가헤 된다. 16.1.6 JPA 비관적 락 데이터베이스 트랜잭션 락 메커니즘에 의존하는 방법이다. SQL의 select for update 구문을 사용하며, 버전정보는 사용하지 않는다. 비관적 락의 장점은 다음과 같다. 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다. 데이터를 수정하는 즉시 트랜잭션 충동을 감지할 수 있다. PESSIMISTIC_WRITE 데이터베이스에 쓰기 락을 걸때 사용한다. 데이터베이스의 select for update를 사용해서 락을 건다. NON-REPEATABLE READ를 방지한다. 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다. PESSIMISTIC_READ(잘 사용하진 않음..) 데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용한다. MySQL의 경우 lock in share mode PostgreSQL의 경우 for share PESSIMISTIC_FORCE_INCREMENT 비관적 락중 유일하게 버전 정보를 사용한다. 비관적 락이지만 버전 정보를 강제로 증가시킨다. 하이버네이트는 nowait를 지원하는 데이터베이스에 대해서 for update nowait옵션을 적용한다. nowait를 지원하지 않으면 for update가 사용된다. 16.1.7 비관적 락과 타임아웃 비관적 락을 사용하면 락을 획득할 때까지 트랜잭션이 대기한다. 무한정 기다릴 수 없기때문에 타임아웃 시간을 줄 수 있다. 타임아웃은 데이터베이스 특성에 따라 동작하지 않을 수 있다. 1Map\u0026lt;String,Object\u0026gt; properties = new HashMap\u0026lt;String,Object\u0026gt;(); 2 3// 타임아웃 10초 설정 4properties.put(\u0026#34;javax.persistence.lock.timeout\u0026#34;,10000); 5 6Board board = em.find(Board.class, \u0026#34;boardId\u0026#34;,LockModeType.PESSIMISTIC_WRITE,properties); ","permalink":"https://92SooJong.github.io/posts/jpa/book-1/16-1-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EB%9D%BD/","summary":"16.1 트랜잭션과 락 16.1.1 트랜잭션과 격리 수준 트랜잭션은 기본적으로 ACID중 원자성, 일관성, 지속성은 만족한다. 여기서 다루기 피곤한 녀석이 격리성이다. 단순히 트랜잭션 간에 간섭이 없도록 격리성을 분리해버리면 테이블 접근이 제한적이기때문에 동시성 처리 성능이 떨어지게된다.\n격리수준(Isolation Level) 동시성 처리를 위해서 대부분의 Database는 READ COMMITED를 기본으로한다\nREAD UNCOMMITTED 커밋하지 않은 데이터를 읽을 수 있다. 트랜잭션1이 데이터를 변경하는 로직을 수행하더라도 트랜잭션2는 데이터를 읽을수 있다. 이를 DIRTY READ라 한다. READ COMMITED 커밋한 데이터만 읽을 수 있다.","title":"16.1 트랜잭션과 락"},{"content":" 스웜 클래식과 스웜 모드는 여러 대의 도커 서버를 하나의 클러스터로 만들어 컨테이너를 생성하는 여러 기능을 제공한다. 개발자는 다양한 전략을 세워 컨테이너를 특정 도커 서버에 할당 할수 있도록 할 수 있다. 스웜 클러스터에 등록된 서버를 손쉽게 관리할 수 있다. 도커 스웜 모드가 실제 운영 환경에서 많이 쓰이진 않는다. 도커 스웜의 종류 컨테이너로서의 스웜 도커 1.6 버전부터 사용 가능 스웜 클래식이라고도 부름 스웜 클래식은 여러 대의 도커 서버를 하나의 지점에서 사용하도록 단일 접근점을 제공하는 방식이다. 스웜 클래식은 docker run docker ps 등 일반적인 도커 명렁어와 도커 API로 클러스터의 서버를 제어하고 관리할 수 있는 기능을 제공한다. 스웜 클래식은 분산 코디네이터, 에이전트 등이 별도로 실행돼야 한다. 도커 스웜 모드 도커 1.12 이후부터 사용 가능 스웜 모드라고 줄여서 부름 스웜 모드는 마이크로서비스 아키텍처의 컨테이너를 다루기 위한 클러스터링 기능에 초점을 맞춘다. 같은 컨테이너를 동시에 여러 개 생성해 필요에 따라 유동적으로 컨테이너의 수를 조절할 수 있다. 컨테이너로의 연결을 분산하는 로드밸런싱 기능을 자체적으로 지원한다. 스웜 몯가 서비스 확장성과 안정성 등 스웜 클래식에 비해 뛰어나다. 스웜 모드는 클러스터링을 위한 모든 도구가 도커 엔진 자체에 내장돼 있다. 참고 ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-2-%EC%8A%A4%EC%9B%9C-%ED%81%B4%EB%9E%98%EC%8B%9D%EA%B3%BC-%EB%8F%84%EC%BB%A4-%EC%8A%A4%EC%9B%9C-%EB%AA%A8%EB%93%9C/","summary":"스웜 클래식과 스웜 모드는 여러 대의 도커 서버를 하나의 클러스터로 만들어 컨테이너를 생성하는 여러 기능을 제공한다. 개발자는 다양한 전략을 세워 컨테이너를 특정 도커 서버에 할당 할수 있도록 할 수 있다. 스웜 클러스터에 등록된 서버를 손쉽게 관리할 수 있다. 도커 스웜 모드가 실제 운영 환경에서 많이 쓰이진 않는다. 도커 스웜의 종류 컨테이너로서의 스웜 도커 1.6 버전부터 사용 가능 스웜 클래식이라고도 부름 스웜 클래식은 여러 대의 도커 서버를 하나의 지점에서 사용하도록 단일 접근점을 제공하는 방식이다.","title":"3.2 스웜 클래식과 도커 스웜 모드"},{"content":" 도커를 적용하기 위한 여러 대의 서버를 하나의 자원 풀로 만들기 위해 등장했다. 새로운 서버나 컨테이너가 추가됐을때 이를 발견(Service Discovery)하는 작업을 수행한다. 어떤 서버에 컨테이너를 할당 할것인가 하는 스케줄러 및 로드밸런서 역할을 수행한다. 클러스터 내의 서버가 다운됐을 때 고가용성(High Availability)을 보장해준다. docker swam과 swam mode는 도커에서 공식적으로 제공한다. ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/3-1-%EB%8F%84%EC%BB%A4-%EC%8A%A4%EC%9B%9C%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/","summary":" 도커를 적용하기 위한 여러 대의 서버를 하나의 자원 풀로 만들기 위해 등장했다. 새로운 서버나 컨테이너가 추가됐을때 이를 발견(Service Discovery)하는 작업을 수행한다. 어떤 서버에 컨테이너를 할당 할것인가 하는 스케줄러 및 로드밸런서 역할을 수행한다. 클러스터 내의 서버가 다운됐을 때 고가용성(High Availability)을 보장해준다. docker swam과 swam mode는 도커에서 공식적으로 제공한다. ","title":"3.1 도커 스웜을 사용하는 이유"},{"content":"2.4 Dockerfile 새로운 이미지를 생성하기 위해 사용하는 일련의 명령어를 실행할 수 있도록 해주는 파일 컨테이너에서 수행해야 할 작업을 명시하고 이미지를 생성한다. 2.4.2 Dockerfile 작성 샘플 파일을 생성한다. Dockerfile을 작성한다. FROM 은 생성할 이미지의 베이스가 될 이미지를 뜻한다. Dockerfile에 반드시 한 번 이상 입력해야한다. MAINTAINER 은 이미지를 생성한 개발자의 정보를 나타낸다. LABEL 은 이미지의 메타데이터를 뜻한다. RUN 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행한다. RUN [\u0026quot;실행가능한 파일\u0026quot;,\u0026quot;명령줄 인자1\u0026quot;,\u0026quot;명령줄 인자 2, ... ] 형태로 작성가능하다. ADD 는 파일을 이미지에 추가한다. Dockerfile이 존재하는 위치에서 test.html을 가져와서 컨테이너에 있는 /var/www/html 경로에 마운트한다. WORKDIR 는 명령어를 실행할 디렉터리 위치를 나타낸다. Bash Shell에서 cd 명령어를 입력하는것과 같은 효과가 있다. EXPOSE 는 컨테이너에서 사용할 포트를 나타낸다. 호스트의 포트 80번과 바인딩 되는게 아님을 기억하자!! CMD 는 컨테이너가 시작될 때마다 실행할 명령어를 설정한다. Dockerfile에서 한번만 사용할 수 있다. 만약 컨테이너를 생성할때 명령어를 입력한다면 Dockerfile에 작성한 CMD 명령어는 무시된다. 1# vi Dockerfile 2 3FROM ubuntu:14.04 4MAINTAINER soojong 5LABEL \u0026#34;purpose\u0026#34;=\u0026#34;practice\u0026#34; 6RUN apt-get update 7RUN apt-get install apache2 -y 8ADD test.html /var/www/html 9WORKDIR /var/www/html 10RUN [\u0026#34;/bin/bash\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;echo hello \u0026gt;\u0026gt; test2.html\u0026#34;] 11EXPOSE 80 12CMD apachectl -DFOREGROUND 2.4.3 Dockerfile 빌드 build 명령어를 사용한다. ./ 경로에 있는 Dockerfile을 빌드한다. ./ 경로가 빌드 컨텍스트가 된다. ( Dockerfile이 위치한곳이 빌드 컨텍스트 ) -t 옵션을 통해서 이미지의 이름을 지정한다. 1sudo docker build -t mybuild:0.0 ./ 이미지 빌드를 시작할때 가장먼저 빌드 컨텍스트에 있는 파일들을 읽는다.s 가능하면 빌드 컨텍스트에는 필요한 파일만 두는게 좋다. 아니면 .dockerignore 파일을 컨텍스트 빌드에 작성하도록 한다. 각 Step은 Dockerfile에 작성된 명령어를 의미한다. 각 Step이 실행될때 마다 새로운 컨테이너가 하나씩 생성되며 다음 컨테이너 생성시 사용된다. 이미지의 빌드가 완료되면 임시로 생성된 컨테이너들은 모두 삭제된다. 캐시 동작 확인해보기 Dockerfile2를 생성해서 아래와 같이 명령어를 작성한다. 1FROM ubuntu:14.04 2MAINTAINER soojong 3LABEL \u0026#34;purpose\u0026#34;=\u0026#34;practice\u0026#34; 4RUN apt-get update -f 옵션을 사용해서 강제로 Dockerfile2를 빌드하도록 한다. 1sudo docker build -f Dockerfile2 -t mycache0.0 ./ 로그에서 Using cache 를 확인할 수 있다. 이전에 빌드했던 Dockerfile에 가튼 내용이 있다면 build 명령어는 이를 새로 빌드하지 않고 같은 명령어 줄까지 이전에 사용한 이미지 레이어를 활용해서 이미지를 생성한다. 아래의 예시는 Step1에서 만들어진 임시 컨테이너를 Step4까지 모두 사용한다. 캐시가 불필요한 경우 Dockerfile 빌드시 캐시 기능을 제외해야하는 경우가 있다. 대표적으로 RUN git clone 같은 경우이다. RUN에 대한 이미지 레이어를 계속 캐시로 사용하기 때문에 저장소에 있는 새로운 소스를 불러오지 못하는 경우가 생긴다. 따라서 --no-cache 옵션을 통해서 빌드시에 캐시기능을 사용하지 않도록 한다. 1sudo docker build --no-cache -y mybuild:0.0 . 멀티 스테이지를 이용한 Dockerfile 빌드하기 샘플용 golang 앱을 만든다. 1package main 2import \u0026#34;fmt\u0026#34; 3func main(){ 4\tfmt.Println(\u0026#34;hello World\u0026#34;); 5} 위 소스코드를 실행하는 이미지를 빌드하기 위한 Dockerfile을 작성한다. 1FROM golang 2ADD main.go /root 3WORKDIR /root 4RUN go build -o /root/mainApp /root/main.go 5CMD [\u0026#34;./mainApp\u0026#34;] Dockerfile을 빌드한다. 1sudo docker build . -t go_helloworld golang 이미지의 사이즈가 크기때문에 전체 이미지가 960MB에 달한다. 멀티 스테이지가 적용된 Dockerfile을 통해서 컴파일된 app만 포함하는 이미지를 만들어본다. 첫번째 FROM 이미지에선 golang을 통해 소스코드 빌드까지만 수행한다. 두번째 FROM 이미지에선 COPY --from=0 을 통해서 첫번째에서 빌드된 App을 2번째 이미지로 가져온다. 두번째 FROM에서 내려받은 이미지로 최종 빌드하게 되므로 컴팩트한 이미지 생성이 가능해진다. 1FROM golang 2ADD main.go /root 3WORKDIR /root 4RUN go build -o /root/mainApp /root/main.go 5 6FROM alpine:latest 7WORKDIR /root 8COPY --from=0 /root/mainApp . 9CMD [\u0026#34;./mainApp\u0026#34;] 용량이 줄어든것을 확인할 수 있다. ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-4-dockerfile/","summary":"2.4 Dockerfile 새로운 이미지를 생성하기 위해 사용하는 일련의 명령어를 실행할 수 있도록 해주는 파일 컨테이너에서 수행해야 할 작업을 명시하고 이미지를 생성한다. 2.4.2 Dockerfile 작성 샘플 파일을 생성한다. Dockerfile을 작성한다. FROM 은 생성할 이미지의 베이스가 될 이미지를 뜻한다. Dockerfile에 반드시 한 번 이상 입력해야한다. MAINTAINER 은 이미지를 생성한 개발자의 정보를 나타낸다. LABEL 은 이미지의 메타데이터를 뜻한다. RUN 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행한다. RUN [\u0026quot;실행가능한 파일\u0026quot;,\u0026quot;명령줄 인자1\u0026quot;,\u0026quot;명령줄 인자 2, ... ] 형태로 작성가능하다.","title":"2.4 Dockerfile"},{"content":"2.3 도커 이미지 이미지 검색 도커는 Docker Hub라는 중앙 이미지 저장소에서 이미지를 내려받는다. search 명령어를 통해 도커 이미지를 검색할 수 있습니다. 이미지 생성 샘플 컨테이너를 생성하고 커스터마이징 해본다. 1sudo docker run -i -t --name commit_test ubuntu:14.04 commit 명령어를 통해서 컨테이너를 이미지로 만들수 있다. -a 옵션은 author를 뜻한다. -m 은 커밋 메시지를 뜻한다. commit_test 컨테이너를 이름은 commit_test이고 태그가 first인 이미지로 생성한다. 1sudo docker commit \\ 2-a \u0026#34;soojong\u0026#34; -m \u0026#34;my first commit\u0026#34; \\ 3commit_test \\ 4commit_test:first 한단계 더 나아가서 commit_test 이미지로 또다른 이미지를 만들어 보자. 1sudo docker run -i -t --name commit_test2 commit_test:first 컨테이너 실행후 second 파일을 생성한다. commit_test2 컨테이너로 이미지를 만든다. 1sudo docker commit \\ 2-a \u0026#34;soojong\u0026#34; -m \u0026#34;my second commit\u0026#34; \\ 3commit_test2 \\ 4commit_test:second 이미지 구조 이미지의 관계는 git의 commit 처럼 관리되기때문에 ubuntu:14.04의 용량이 190MB라도 commit_test:first 이미지의 용량은 190MB가 아닌 추가된 파일의 용량이 된다. ubuntu:14.04 이미지의 용량 + 추가된 파일의 용량 아래는 ubuntu:14.04의 이미지 ID와 Layer 정보이다. 아래는 commit_test:first 이미지의 ID와 Layer 정보다. 아래는 commit_test:second 이미지의 ID와 Layer 정보다. 이미지 삭제 rmi 명령어를 사용해서 이미지를 삭제한다. 1sudo docker rmi commit_test:first 이미지를 사용중인 컨테이너가 존재하면 아래와 같은 에러가 발생한다. 먼저 컨테이너를 중단 및 삭제한다. 1sudo docker stop commit_test2 \u0026amp;\u0026amp; sudo docker rm commit_test2 아래와 같이 Untagged 문구가 뜨면 이름만 삭제한다는 뜻이다. 삭제하고 싶은 이미지를 사용해서 만들어진 또다른 이미지가 있기때문이다. Delete 문구가 출력되면 실제로 이미지 레이어가 삭제됐음을 의미한다. 이미지 배포 TODO - 배포 수행시 작성하기! ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-3-%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80/","summary":"2.3 도커 이미지 이미지 검색 도커는 Docker Hub라는 중앙 이미지 저장소에서 이미지를 내려받는다. search 명령어를 통해 도커 이미지를 검색할 수 있습니다. 이미지 생성 샘플 컨테이너를 생성하고 커스터마이징 해본다. 1sudo docker run -i -t --name commit_test ubuntu:14.04 commit 명령어를 통해서 컨테이너를 이미지로 만들수 있다. -a 옵션은 author를 뜻한다. -m 은 커밋 메시지를 뜻한다. commit_test 컨테이너를 이름은 commit_test이고 태그가 first인 이미지로 생성한다. 1sudo docker commit \\ 2-a \u0026#34;soojong\u0026#34; -m \u0026#34;my first commit\u0026#34; \\ 3commit_test \\ 4commit_test:first 한단계 더 나아가서 commit_test 이미지로 또다른 이미지를 만들어 보자.","title":"2.3 도커 이미지"},{"content":"2.2 도커 컨테이너 다루기 컨테이너 실행해보기 run 명령어를 사용해서 우분투 14.04 컨테이너 실행하기\n1docker run -i -t ubuntu:14.04 로컬에 설치된 이미지가 없기 때문에 내려받아서 컨테이너를 실행 시켜줌.\n사용자 이름을 보면 알 수 있듯이 컨테이너 내부에 들어온것을 볼수 있다.\n-i 옵션으로 상호 입출력을 가능하게 한다.\n-t 옵션으로 tty를 활성화 해서 bash shell을 사용할 수 있도록 한다.\n두 옵션이 없으면 shell을 정상적으로 사용할 수 없게 된다.\ncreate 명령어를 사용해서 centos 컨테이너를 생성한다. --name 옵션을 통해서 컨테이너의 이름을 설정한다. start 명령어를 통해 컨테이너를 실행한다. attach 명령어를 통해 컨테이너 내부로 들어간다. run 명령어는 start 와 attach 명령어를 실행해준다. 반대로 create 명령어를 실행하지 않고 컨테이너 생성까지만 수행한다. run 과 create 는 기본적으노 pull 명령어와 create 명령어를 수행한다. pull 은 이미지가 존재하지 않을때 원격 저장소에서 이미지를 가져올 수 있도록 하며, create 는 이미지로 컨테이너를 만드는 일을 수행한다. 조회, 삭제, 종료 exit 입력 또는 Ctrl + D 를 입력하면 된다.\n이때 컨테이너가 중단되는 것에 주의한다.\nCtrl + P, Q 를 입력하면 컨테이너를 정지하지 않고 빠져나올 수 있다.(3개를 동시에 누르는게 아니라 P먼저 누르고 Q를 눌러야 함)\n도커 엔진에 존재하는 이미지의 목록 조회는 images 명령어를 사용한다.\n1docker images 실행중인 컨테이너 목록 확인은 ps 명령어를 사용한다. COMMAND는 컨테이너가 실행될때 수행할 명령어를 뜻한다. 정지된 컨테이너까지 조회하려면 -a 옵션을 사용하면 된다. 컨테이너를 중지하려면 stop 명령어를 사용하면 된다. 컨테이너 삭제는 rm 명령어를 사용하면 된다. 일괄중지는 sudo docker stop $(sudo docker ps -a -q) 명령어를 사용한다. 일괄삭제는 sudo docker rm $(sudo docker ps -a -q) 명령어를 사용한다. 컨테이너 외부 노출 테스트를 위한 우분투 컨테이너를 실행한다. 1sudo docker run -i -t --name network_test ubuntu:14.04 컨테이너에서 ifconfig 명령어를 실행한다. 컨테이너는 기본적으로 172.17.0.x IP를 할당받는다. 컨테이너는 외부에서 접속은 불가능 하며 호스트에서만 접근이 가능한 상태다. 외부 노출을 위해 eth0의 IP와 포트를 호스트의 IP와 포트에 바인딩 해야한다. -p 옵션을 사용해서 [호스트의 포트]:[컨테이너의 포트] 형태로 바인딩한다. -p 옵션을 여러번 사용해서 포트를 여러개 바인딩 할수도 있다. 단순히 -p 80 과 같이 입력할 수 있는데 이때는 호스트의 포트가 랜덤으로 배정되기 때문에 ps 명령어를 통해서 확인해야한다. 1sudo docker run -i -t --name mywebserer -p 80:80 ubuntu:14.04 우분투 컨테이너에 아파치 웹서버를 설치하고 실행한다. 1apt-get update 2apt-get install apache2 -y 3service apache2 start 웹 브라우저를 통해 접속해본다. 샘플 애플리케이션 구축 데이터베이스와 웹서버를 하나의 컨테이너로 관리하기 보단 나눠서 컨테이너를 생성하고 관리하도록 하자. mysql 컨테이너를 실행한다. -d 옵션은 컨테이너를 백그라운드에서 동작하는 애플리케이션으로써 실행하도록 한다. -e 옵션은 컨테이너 내부의 환경변수를 설정한다. --link 옵션을 통해서 컨테이너간 네트워킹이 가능하도록 해준다. 컨테이너의 IP는 동적으로 할당되기 때문에 alias를 사용해서 연결한다. 컨테이너가 실행중이지 않다면 에러가 발생한다. 추후 삭제될 가능성이 높은 옵션이므로 브리지 네트워크 기능으로 연결하도록 하자. 1sudo docker run -d \\ 2--name wordpressdb \\ 3-e MYSQL_ROOT_PASSWORD=password \\ 4-e MYSQL_DATABASE=wordpress \\ 5mysql:5.7 wordpress 웹서버 컨테이너를 실행한다. 1sudo docker run -d \\ 2-e WORDPRESS_DB_HOST=mysql \\ 3-e WORDPRESS_DB_USER=root \\ 4-e WORDPRESS_DB_PASSWORD=password \\ 5--name wordpress \\ 6--link wordpressdb:mysql \\ 7-p 80 \\ 8wordpress wordpress 웹 서버 컨테이너와 바인딩된 호스트의 IP를 확인한다. 정상적으로 접속된다. 컨테이너 입출력 -d 옵션으로 run 을 실행하면 입출력이 없는 상태로 컨테이너를 실행한다. 컨테이너 내부에서 프로그램이 터미널을 차지하는 foreground로 실행되기 때문이다. 따라서 -d 옵션을 사용한 컨테이너는 반드시 컨테이너 내에서 foreground로 프로그램이 실행되도록 해야한다.(터미널에 프로그램을 할당해야한다.) 그렇지 않은 경우는 컨테이너가 즉시 종료 된다. ubuntu 컨테이너를 -d 옵션을 걸어서 실행하면 아래처럼 바로 종료된다. MySql 컨테이너에 -i -t 옵션을 걸면 컨테이너로 접속해서 컨테이너에서 foreground로 실행되고 있는 프로그램을 확인할 수 있다. 상호 입출력은 불가능하고 단순히 foreground로 구동되는 프로그램의 로그만 볼 수있다. 1sudo docker run -i -t \\ 2--name mysql_attach_test \\ 3-e MYSQL_ROOT_PASSWORD=password \\ 4-e MYSQL_DATABASE=wordpress \\ 5mysql:5.7 컨테이너 내부에서 echo ${환경변수명} 명령어를 입력하면 환경변수 확인이 가능하다. echo 명령어를 사용하기 위해선 상호 입출력이 가능한 shell이 컨테이너에서 실행되어야한다. 위의 mysql 컨테이너는 이미 attach로 접근해도 foreground로 프로그램이 이미 실행중이다. 따라서 exec 명령어를 사용하도록 한다. exec 명령어를 사용하면 컨테이너 내보의 shell을 사용할 수 있다. 1sudo docker exec -i -t mysql_attach_test /bin/bash mysql -u root -p 를 통해 password가 올바르게 적용되었는지 확인해본다. exit 명령어로 빠져나와도 컨테이너가 종료되지 않는다. 도커 볼륨 이미 생성된 이미지는 어떠한 경우로도 변경되지 않는다. mysql 컨테이너를 생성했다면, 컨테이너에 운영중 생성된 데이터들이 저장된다. 이때 컨테이너를 삭제하면 컨테이너에 존재하던 데이터도 함께 삭제된다. 컨테이너에 있는 데이터의 영속성을 확보하기 위해 볼륨을 활용한다. 호스트 볼륨 공유 -v 옵션을 통해 호스트의 /home/wordpress_db 디렉터리와 컨테이너의 /var/lib/mysql 을디렉터리를 공유한도록 한다. 호스트에 해당 디렉터리가 없다면 자동으로 생성해준다. 이미 호스트에 존재하는 디렉터리인 경우 호스트의 디렉터리를 컨테이너 디렉터리에 덮어쓰기 한다. 즉, 호스트가 우선순위가 더 높다. 1sudo docker run -d \\ 2--name wordpressdb_hostvolume \\ 3-e MYSQL_ROOT_PASSWORD=password \\ 4-e MYSQL_DATABASE=wordpress \\ 5-v /home/wordpress_db:/var/lib/mysql \\ 6mysql:5.7 wordpress 웹서버 컨테이너를 실행한다. 1sudo docker run -d \\ 2-e WORDPRESS_DB_PASSWORD=password \\ 3--name wordpress_hostvolume \\ 4--link wordpressdb_hostvolume:mysql \\ 5-p 80 \\ 6wordpress 볼륨 컨테이너 -v 옵션을 사용하는 컨테이너와 연결하는 방법이다. 한마디로 -v 옵션을 사용하는 컨테이너를 브리지로 사용하는것이다 --volumes-from 옵션을 사용하면 된다. 도커 볼륨 volume create 명령어를 통해 도커 자체에서 제공하는 볼륨 기능을 사용할 수 있다. 해당 볼륨은 도커 엔진에 의해 제어된다. 1sudo docker volume create --name myvolume 여러 종류의 스토리지를 사용할 수 있으며, 아래는 호스트(local)의 스토리지를 사용하도록 한다. 1sudo docker volume ls myvolume_1,myvolume_2 컨테이너가 myvolume 볼륨 컨테이너를 사용하도록 한다. myvolume_1 컨테이너에 접속해서 /root 디렉토리 아래에 파일을 생성하면, myvolume_2 컨테이너의 /root 디렉토리 파일에서 확인이 가능하게 된다. 1sudo docker run -i -t --name myvolume_1 \\ 2-v myvolume:/root/ \\ 3ubuntu:14.04 1sudo docker run -i -t --name myvolume_2 \\ 2-v myvolume:/root/ \\ 3ubuntu:14.04 inspect 명령어를 통해서 도커 볼륨이 호스트의 어떤 디렉터리에서 저장되고 있는지 확인할 수 있다. 1sudo docker inspect --type volume myvolume 도커 네트워크 호스트에서 ifconfig 명령어를 입력하면 실행중인 컨테이너의 개수 만큼 veth가 생성된것을 확인할 수 있다. eth0는 공인 IP 또는 내부 IP가 할당되어 실제로 외부와 통신할 수 있는 호스트의 네트워크 인터페이스이다. docker0는 eth0와 veth의 중간 다리 역할을 한다. 컨테이너는 호스트의 veth… 과 연결되며 veth…은 docker0와 연결되어 외부와 통신할 수 있게된다. (docker0는 호스트의 eth0와 연결!) 도커 네트워크 기능 컨테이너를 생성하면 docker0 브리지를 통해서 외부와 통신할 수 있는 환경을 제공받는다. 사용자의 선택에 따라 여러 네트워크 드라이버 사용이 가능하다. 대표적으로 브리지(bridge), 호스트(host), 논(none), 컨테이너(container), 오버레이(overlay)가 있다. docker network ls 명령어를 통해 사용가능한 네트워크를 확인할 수 있다. 이미 bridge, host, none이 존재하는걸 확인할 수 있다. bridge 네트워크는 컨테이너를 생성할 때 자동으로 연결되는 docker0 브리지를 활용하도록 설정되어있다.\n이 네트워크는 172.17.0.x IP대역을 순차적으로 할당한다.\ndocker network inspect 명령어를 통해 네트워크의 자세한 정보를 확인할 수 있다.브리지 네트워크\n브리지 네트워크 docker network create --driver bridge mybridge 명령어를 사용하면 기존의 docker0 브리지가 아닌 새로운 브리지 네트워크 생성이가능하다. (mybridge 브리지 네트워크 생성)\n컨테이너 생성시에 --net 옵션을 사용해서 생성한 브리지 사용이 가능하다.\n1docker run -i -t --name mynetwork_container \\ 2--net mybridge \\ 3ubuntu:14.04 connect disconnect 명령어를 통해서 컨테이너에 네트워크를 유동적으로 붙였다 뗐다 할수 있다.\n다만 브리지 네트워크, 오버레이 네트워크와 같이 특정 IP 대역을 갖는 네트워크 모드에서만 사용이 가능하다.\n아래와 같이 다양한 옵션을 사용해서 원하는 대역폭이나 gateway를 설정할 수 있다.( --subnet 과 --ip-range 는 같은 대역을 가져야 한다. )\n1docker network create --driver=bridge \\ 2--subnet=172.72.0.0/16 \\ 3--ip-range=172.72.0.0/24 \\ 4--gateway=172.72.0.1 \\ 5my_custom_network 호스트 네트워크 호스트의 네트워크 환경을 그대로 쓰는 방식이다.\n별도의 네트워크 생성이 필요 없으며, 기존의 host라는 이름의 네트워크를 그대로 사용한다.\n1docker run -i -t --name network_host \\ 2--net host \\ 3ubuntu:14.04 컨테이너에서 ifconfig를 수행하면 호스트의 네트워크가 정보가 출력된다.\n사실상 호스트에서 서비스를 구동하는 것과 같은 효과를 가지게 된다.\n논 네트워크 none은 아무런 네트워크를 쓰지않는 것을 뜻한다.\n1docker run -i -t --name network_none \\ 2--net none \\ 3ubuntu:14.04 컨테이너 네트워크 다른 컨테이너의 네트워크 네임스페이스 환경을 공유할 수 있다.\n공유되는 속성으로는 내부IP, 네트워크 인터페이스의 맥(MAC) 주소 등이 있다.\n--net container:[다른 컨테이너의 ID] 와 같이 작성하면 된다.\n1docker run -i -t -d --name network_container_1 ubuntu:14.04 2 3docker run -i -t -d --name network_container_2 \\ 4--net container:network_container_1 \\ 5ubuntu:14.04 두 컨테이너의 네트워크가 같은 것을 확인할 수 있다.\n컨테이너 네트워크의 구조를 그림으로 표현하면 아래와 같다.\n브리지 네트워크와 \u0026ndash;net-alias 브리지 타입의 네트워크와 --net-alias 옵션을 함께 사용하면 특정 호스트 이름으로 컨테이너 여러 개에 접근 할 수 있다.\n1docker run -i -t -d --name network_alias_container_1 \\ 2--net mybridge \\ 3--net-alias alicek106 \\ 4ubuntu:14.04 5 6docker run -i -t -d --name network_alias_container_2 \\ 7--net mybridge \\ 8--net-alias alicek106 \\ 9ubuntu:14.04 10 11docker run -i -t -d --name network_alias_container_3 \\ 12--net mybridge \\ 13--net-alias alicek106 \\ 14ubuntu:14.04 위 명령어를 그림으로 나타내면 아래와 같다.\nmybridge 라는 네트워크에 속한 3개의 컨테이너는 --net-alias 옵션에 alicek106이라는 값을 입력했다.\n이 컨테이너의 IP는 DNS서버에 alicek106이라는 호스트 이름으로 등록된다.\nmybridge 네트워크에 속한 컨테이너에게 alicek106이라는 호스트 이름으로 접근하면 도커 내장 DNS는 라운드로빈 방식으로 컨테이너의 IP리스트를 반환한다.\nping은 IP 리스트에서 첫번째 IP를 사용하므로 매번 다른 IP를 응답하게 된다. ( DNS 서버는 라운드 로빈방식으로 컨테이너의 IP 리스트를 반환하기 때문이다. )\nMacVLAN 네트워크 호스트의 네트워크 인터페이스 카드를 가상화해 물리 네트워크 환경을 컨테이너에게 동일하게 제공하는 방식이다.\nMacVLAN을 사용하면 컨테이너도 가상의 Mac 주소를 가지게 된다.\n덕분에 해당 네트워크에 연결된 다른 장치와의 통신이 가능하게 된다.\n다만, 컨테이너A는 서버2,컨테이너B와 통신이 가능하지만 서버1(자신의 호스트)과는 통신이 불가능하다.\n컨테이너 로깅 ","permalink":"https://92SooJong.github.io/posts/docker/book/%EC%8B%9C%EC%9E%91%ED%95%98%EC%84%B8%EC%9A%94-%EB%8F%84%EC%BB%A4-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4/2-2-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EB%8B%A4%EB%A3%A8%EA%B8%B0/","summary":"2.2 도커 컨테이너 다루기 컨테이너 실행해보기 run 명령어를 사용해서 우분투 14.04 컨테이너 실행하기\n1docker run -i -t ubuntu:14.04 로컬에 설치된 이미지가 없기 때문에 내려받아서 컨테이너를 실행 시켜줌.\n사용자 이름을 보면 알 수 있듯이 컨테이너 내부에 들어온것을 볼수 있다.\n-i 옵션으로 상호 입출력을 가능하게 한다.\n-t 옵션으로 tty를 활성화 해서 bash shell을 사용할 수 있도록 한다.\n두 옵션이 없으면 shell을 정상적으로 사용할 수 없게 된다.\ncreate 명령어를 사용해서 centos 컨테이너를 생성한다. --name 옵션을 통해서 컨테이너의 이름을 설정한다.","title":"2.2 도커 컨테이너 다루기"},{"content":"정의 데이터베이스 엔진(또는 스토리지 엔진)은 데이터베이스 관리 시스템(DBMS)에서 작동하는 소프트웨어 중 하나다. DBMS는 데이터베이스 엔진을 사용해서 데이터베이스로부터 데이터를 생성,조회,삭제,수정(CRUD)를 하게된다. 대부분의 DBMS는 데이터베이스 엔진과 상호작용을 위한 자신만의 API를 가지고 있다. 즉, 사용자가 직접 데이터베이스 엔진을 조직할 일은 없다. \u0026ldquo;데이터베이스 인스턴스\u0026quot;는 실행 중인 데이터베이스 엔진의 프로세스 및 메모리 구조를 말한다. 많은 DBMS들이 복수개의 데이터베이스 엔진을 지원한다. ( ex. MySQL은 InnoDB와 MyISAM 엔진을 지원한다. ) ","permalink":"https://92SooJong.github.io/posts/database/database-engine/","summary":"정의 데이터베이스 엔진(또는 스토리지 엔진)은 데이터베이스 관리 시스템(DBMS)에서 작동하는 소프트웨어 중 하나다. DBMS는 데이터베이스 엔진을 사용해서 데이터베이스로부터 데이터를 생성,조회,삭제,수정(CRUD)를 하게된다. 대부분의 DBMS는 데이터베이스 엔진과 상호작용을 위한 자신만의 API를 가지고 있다. 즉, 사용자가 직접 데이터베이스 엔진을 조직할 일은 없다. \u0026ldquo;데이터베이스 인스턴스\u0026quot;는 실행 중인 데이터베이스 엔진의 프로세스 및 메모리 구조를 말한다. 많은 DBMS들이 복수개의 데이터베이스 엔진을 지원한다. ( ex. MySQL은 InnoDB와 MyISAM 엔진을 지원한다. ) ","title":"Database Engine"},{"content":" 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. 인덱스의 핵심 요소는 2가지로 나눌수 있다. 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다.(인덱스 스캔 효율화 튜닝) 테이블 액세스 횟수를 줄이는 것이다. 인덱스를 사용하면 테이블을 전체읽지 않고 일부만 읽고 멈출 수 있다. 즉, 범위 스캔(Range Scan)이 가능하다. 범위스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문이다. DBMS에선 일반적으로 B(Balanced)-Tree 인덱스를 많이 사용한다. 과거에 작성한 내용 어떤 데이터를 찾기위한 색인 Index도 하나의 데이터베이스 객체이기 때문에 저장 공간이 필요하다. 1create index [인덱스명] on [테이블명](컬럼명1, 컬럼명2 ... ); Full Table Scan 테이블에 있는 모든 데이터를 읽어서 원하는 데이터를 찾아낸다. Binary Search 사용하기 위해선 데이터가 정렬되어 있어야 한다. 데이터의 가운데 위치(값이 아님!!)에 있는 값을 확인한다. 찾으려고 하는 값보다 작다면 좌측을 버리고, 찾으려고 하는 값보다 크다면 우측을 모두 버린다. Binary Search Tree 자식노드가 최대 2개까지만 존재할 수 있는 트리이다. 데이터가 정렬된 채로 트리를 이루고 있다. 즉, 특정 노드를 선택하면 해당 노드의 subtree들 중 좌측에 있는 노드는 모두 작은 값이다. B-Tree ( Balanced Tree ) Binary Tree와 달리 높이(Height)가 같은 Tree Clustered Index 군집화된 인덱스라는 뜻이며, 좀더 풀어서 설명하면 인덱스와 데이터가 한데 모여있다는 뜻이다. 데이터가 이미 PK를 기준으로 정렬되어 있기때문에 범위검색할때 높은 효율을 보인다. 특정 범위를 그냥 긁어오기만 하면됨. PK로 정렬을 해야되기 때문에 PK가 하나로 이뤄진 테이블일때 좋다. 따라서 Auto_Increment로 PK를 따는게 좋다. 테이블 중간에 Insert를 하게된다면 페이지 분할 작업을 수행해야하기때문에 성능 저하를 가져올 수 있다. Non-Clustered Index 데이터와 연결되어 있지않고, 어떤 인덱스와 연결되어 있다. 순서와 상관이 없고 Hash함수 방식으로 찾아내기때문이다. 한 테이블에 여러개의 PK가 있을수 있다. PK를 찾아서 또다른 PK를 찾아갈 수 있음. PK를 찾기위해 추가적인 저장공간이 10% 필요하다. Insert를 수행하면 인덱스 생성을 위한 추가 작업이 생긴다. 중복된 데이터가 많을수록 Cardinality는 떨어진다. ( ex. 성별 같은 컬럼은 50대50이기때문에 굳이 인덱싱 테이블을 볼 필요가 없이 풀스캔하는게 낫다. ) 주민등록 번호같이 고유한 데이터일수록 Cardinality가 높다고 말한다. Cardinality가 높을수록 인덱스 사용을 고려하라!! ","permalink":"https://92SooJong.github.io/posts/database/index/","summary":"인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. 인덱스의 핵심 요소는 2가지로 나눌수 있다. 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다.(인덱스 스캔 효율화 튜닝) 테이블 액세스 횟수를 줄이는 것이다. 인덱스를 사용하면 테이블을 전체읽지 않고 일부만 읽고 멈출 수 있다. 즉, 범위 스캔(Range Scan)이 가능하다. 범위스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문이다. DBMS에선 일반적으로 B(Balanced)-Tree 인덱스를 많이 사용한다. 과거에 작성한 내용 어떤 데이터를 찾기위한 색인 Index도 하나의 데이터베이스 객체이기 때문에 저장 공간이 필요하다.","title":"Index"},{"content":"트랜잭션 트랜잭션은 기본적으로 ACID중 원자성, 일관성, 지속성은 만족한다. 여기서 다루기 피곤한 녀석이 격리성이다. 단순히 트랜잭션 간에 간섭이 없도록 격리성을 분리해버리면 테이블 접근이 제한적이기때문에 동시성 처리 성능이 떨어지게된다. Isolation Level 정의 트랜잭션들 끼리 일관된 데이터를 얼마나 허용할 것인지를 정하는 수준이다.\n종류 총 4가지의 단계가 존재한다. 고립 수준(레벨)이 높아질수록 동시성은 낮아지며, 일관성은 높아진다. 즉, 고립이 심해질수록 동시 접근성은 떨어지지만, 데이터가 일관되게 관리됨을 의미한다.\nLevel 0 Read Uncommitted Transaction A가 수행되는 와중에 Transaction B가 데이터를 변경할 수 있다. 이럴때 A는 변경되기 전의 데이터를 읽을 가능성이 있다. 이를 Dirty Read라고 한다. 동시성은 높으나 일관성이 떨어짐, 가능하면 사용하지 말것 발생가능한 이상현상 : Dirty Read, Non Repeatable Read, Phantom Read Level 1 Read Committed 트랜잭션이 작업하는 시점에 Lock을 건다. 트랜잭션1이 회원A를 조회중일때, 트랜잭션2가 회원A 정보를 수정하고 커밋을 하면 트랜잭션 1이 다시 회원 A를 조회했을때 수정된 데이터가 조회된다. 하나의 트랜잭션에서 같은 회원A 정보를 얻지 못하는 현상이 발생하게된다. 이를 NON-REPEATABLE READ라 한다. 대부분의 DB의 고립레벨이다. (MySQL 제외) 발생가능한 이상현상 : Non Repeatable Read, Phantom Read Level 2 Repeatable Read 트랜잭션 1이 10살 이하의 회원을 조회했는데 트랜잭션 2가 5살 회원을 추가하고 커밋하면 트랜잭션1이 다시 10살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다. 이처럼 반복 조회시 결과 집합(개수)가 달라지는 것을 PHANTOM READ라고한다. MySQL의 고립레벨이다. 발생가능한 이상현상 : Phantom Read Level 3 Serializable 데이터의 안정성이 매우 중요한 특수한 상황이 아닌 이상 거의 사용하지 않음 발생가능한 이상현상은 없다. ","permalink":"https://92SooJong.github.io/posts/database/isolation-level/","summary":"트랜잭션 트랜잭션은 기본적으로 ACID중 원자성, 일관성, 지속성은 만족한다. 여기서 다루기 피곤한 녀석이 격리성이다. 단순히 트랜잭션 간에 간섭이 없도록 격리성을 분리해버리면 테이블 접근이 제한적이기때문에 동시성 처리 성능이 떨어지게된다. Isolation Level 정의 트랜잭션들 끼리 일관된 데이터를 얼마나 허용할 것인지를 정하는 수준이다.\n종류 총 4가지의 단계가 존재한다. 고립 수준(레벨)이 높아질수록 동시성은 낮아지며, 일관성은 높아진다. 즉, 고립이 심해질수록 동시 접근성은 떨어지지만, 데이터가 일관되게 관리됨을 의미한다.\nLevel 0 Read Uncommitted Transaction A가 수행되는 와중에 Transaction B가 데이터를 변경할 수 있다.","title":"Isolation Level"},{"content":"기본키 매핑 방식 직접 할당 기본 키를 애플리케이션에서 직접 할당한다 자동 생성 IDENTITY 기본키 생성을 데이터베이스에 위임한다. MySQL의 경우 AUTO_INCREMENT를 ID 컬럼에 옵션으로 붙여서 테이블을 생성한다. IDENTITY 방식은 실제 Table에 Insert를 수행할때 ID가 할당된다. ID를 얻으려면 Table을 조회해야하는 비효율이 발생하는데 Insert와 동시에 JPA로 ID를 가져오기 위해 Statement.getGeneratedKeys()를 사용하면 된다. 엔터티가 영속 상태가 되려면 식별자가 반드시 필요하기때문에 em.persist()를 호출하는 즉시 Insert 쿼리문에 데이터베이스에 전달된다. 따라서 IDENTITY 방식은 쓰기 지연이 동작하지 않는다. SEQUENCE 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다. 당연히 시퀀스를 지원하는 데이터베이스에서만 사용할 수 있다. 오라클, PostgreSQL, DB2, H2에서 사용가능. JPA는 최적화를 위해 시퀀스를 Bulk로 DB에서 가져올 수 있는 기능을 제공한다. 단, 시퀀스 테이블의 숫자가 한번에 많이 TABLE 키 생성 테이블을 사용한다. 키 생성용 테이블을 하나 만들어두고 마치 시퀀스처럼 사용하는 방법 테이블을 활용하는 방식이기때문에 모든 데이터베이스에서 사용할 수 있다. AUTO 위 3개 전략중 1개를 자동으로 선택한다. 개발 초기 단계에 DB가 정해지지 않았을때 사용하면 편리하다. AUTO를 통해 SEQUENCE나 TABLE 전략이 선택된 경우 키 생성용 테이블을 미리 만들어 두어야 한다. 스키마 자동생성 기능을 켜뒀다면 알아서 키 생성 테이블이 만들어 짐. 기타 오라클 데이터베이스는 시퀀스를 제공하지만 MySQL은 시퀀스를 제공하지 않는다. MySQL은 기본 키 값을 자동으로 채워주는 AUTO_INCREMENT 기능을 제공한다. 따라서 SEQUENCE나 IDENTITY는 사용하는 테이블에 의존한다. ","permalink":"https://92SooJong.github.io/posts/jpa/%EA%B8%B0%EB%B3%B8%ED%82%A4-%EB%A7%A4%ED%95%91/","summary":"기본키 매핑 방식 직접 할당 기본 키를 애플리케이션에서 직접 할당한다 자동 생성 IDENTITY 기본키 생성을 데이터베이스에 위임한다. MySQL의 경우 AUTO_INCREMENT를 ID 컬럼에 옵션으로 붙여서 테이블을 생성한다. IDENTITY 방식은 실제 Table에 Insert를 수행할때 ID가 할당된다. ID를 얻으려면 Table을 조회해야하는 비효율이 발생하는데 Insert와 동시에 JPA로 ID를 가져오기 위해 Statement.getGeneratedKeys()를 사용하면 된다. 엔터티가 영속 상태가 되려면 식별자가 반드시 필요하기때문에 em.persist()를 호출하는 즉시 Insert 쿼리문에 데이터베이스에 전달된다. 따라서 IDENTITY 방식은 쓰기 지연이 동작하지 않는다. SEQUENCE 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.","title":"기본키 매핑 방식"},{"content":" FEAT : 새로운 기능의 추가 FIX: 버그 수정 DOCS: 문서 수정 STYLE: 스타일 관련 기능(코드 포맷팅, 세미콜론 누락, 코드 자체의 변경이 없는 경우) REFACTOR: 코드 리펙토링 TEST: 테스트 코트, 리펙토링 테스트 코드 추가 CHORE: 빌드 업무 수정, 패키지 매니저 수정(ex .gitignore 수정 같은 경우) 출처 https://jason-api.tistory.com/89\n","permalink":"https://92SooJong.github.io/posts/git/commit-message-convention/","summary":"FEAT : 새로운 기능의 추가 FIX: 버그 수정 DOCS: 문서 수정 STYLE: 스타일 관련 기능(코드 포맷팅, 세미콜론 누락, 코드 자체의 변경이 없는 경우) REFACTOR: 코드 리펙토링 TEST: 테스트 코트, 리펙토링 테스트 코드 추가 CHORE: 빌드 업무 수정, 패키지 매니저 수정(ex .gitignore 수정 같은 경우) 출처 https://jason-api.tistory.com/89","title":"Commit 컨벤션"},{"content":"사실 쓰려고 하면 기억 안나서 구글링 하는 명령어 모음 원격의 삭제된 브랜치를 로컬 커밋 히스토리에 반영할때 git remote prune origin\nUndo Commit git reset --soft HEAD^ Or git reset --mixed HEAD^\nfollowing command work same as git reset --soft HEAD^\ngit reset HEAD^\n원격 브랜치의 히스토리를 로컬 브랜치의 히스토리로 강제로 덮어쓴다. git push -f -u origin [branch명]\n원격 브랜치의 주소를 재설정하는 경우 git remote set-url \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt;\ntoken 변경 git remote set-url \u0026lt;remote_name\u0026gt; https://\u0026lt;token\u0026gt;@\u0026lt;git repo url\u0026gt;\nexample, git remote set-url origin https://\u0026lt;token\u0026gt;@github.com/92SooJong/java-study.git\n","permalink":"https://92SooJong.github.io/posts/git/%EC%9E%90%EC%A3%BC%EC%93%B0%EB%8A%94%EB%AA%85%EB%A0%B9%EC%96%B4/","summary":"사실 쓰려고 하면 기억 안나서 구글링 하는 명령어 모음 원격의 삭제된 브랜치를 로컬 커밋 히스토리에 반영할때 git remote prune origin\nUndo Commit git reset --soft HEAD^ Or git reset --mixed HEAD^\nfollowing command work same as git reset --soft HEAD^\ngit reset HEAD^\n원격 브랜치의 히스토리를 로컬 브랜치의 히스토리로 강제로 덮어쓴다. git push -f -u origin [branch명]\n원격 브랜치의 주소를 재설정하는 경우 git remote set-url \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt;\ntoken 변경 git remote set-url \u0026lt;remote_name\u0026gt; https://\u0026lt;token\u0026gt;@\u0026lt;git repo url\u0026gt;","title":"자주 쓰는 명령어"},{"content":"자바 5에 처음 도입되었다.\n예제 Box\u0026lt;T\u0026gt;에서 T는 타입 변수(type variable)이라한다. 타입변수는 꼭 T가 아니어도 된다. 예. Map\u0026lt;K,V\u0026gt; 기호의 종류만 다를 뿐 임의의 참조형 타입을 의미. Object 타입을 사용하다보면 형변환을 필수적으로 해줘야하는데 제네릭은 형변환에서 자유롭다. 1class Box\u0026lt;T\u0026gt;{ 2 T item; 3 4 void setItem(T item){ 5 this.item = item; 6 } 7 T getItem(){ 8 return this.item; 9 } 10 11 } 1Box\u0026lt;String\u0026gt; b = new Box\u0026lt;String\u0026gt;(); 2b.setItem(new Object()); // 에러남. String 타입으로 넘겨야함 3b.setItem(\u0026#34;ABC\u0026#34;); // 성공 4String item = b.getItem(); // 형변환을 하지 않고 가져온다 용어정리 class Box\u0026lt;T\u0026gt; {} Box\u0026lt;T\u0026gt;를 제네릭 클래스 T 타입변수 또는 타입 매개변수 Box 원시타입 특징 static 메소드에는 타입변수 T를 사용할 수 없다. T[] tmpArr = new T[5];와 같은 배열 생성이 불가능하다 T[] itemarr;과 같은 코드는 가능하다.(즉, 참조변수 생성까지만 가능) Box\u0026lt;Fruit\u0026gt; appleBox = new Box\u0026lt;Apple\u0026gt; 자식관계를 반영해주지 않기때문에 이 코드는 에러가 발생한다. 제한된 제네릭 클래스 특정 타입변수만 사용하도록 하고 싶을때 사용하는 기능이다. T에는 Fruit의 자식 타입만 올 수 있다. Fruit가 인터페이스 일때도 extends 키워드를 사용해아한다. 1class FruitBox\u0026lt;T extends Fruit\u0026gt;{ 2 ArrayList\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); 3} ","permalink":"https://92SooJong.github.io/posts/java/%EC%A0%9C%EB%84%A4%EB%A6%AD/","summary":"자바 5에 처음 도입되었다.\n예제 Box\u0026lt;T\u0026gt;에서 T는 타입 변수(type variable)이라한다. 타입변수는 꼭 T가 아니어도 된다. 예. Map\u0026lt;K,V\u0026gt; 기호의 종류만 다를 뿐 임의의 참조형 타입을 의미. Object 타입을 사용하다보면 형변환을 필수적으로 해줘야하는데 제네릭은 형변환에서 자유롭다. 1class Box\u0026lt;T\u0026gt;{ 2 T item; 3 4 void setItem(T item){ 5 this.item = item; 6 } 7 T getItem(){ 8 return this.item; 9 } 10 11 } 1Box\u0026lt;String\u0026gt; b = new Box\u0026lt;String\u0026gt;(); 2b.setItem(new Object()); // 에러남. String 타입으로 넘겨야함 3b.","title":"제네릭"},{"content":"Javascript 개요 역사 Brendan Eich에 의해 1995년에 만들어졌으며 1997년에 ECMA 표준이되었다. 모카 -\u0026gt; 라이브스크립트 -\u0026gt; 자바스크립트 -\u0026gt; ECMA스크립트 현재는 ECMAScript6가 작업중 script 태그 script 태그를 만나면 브라우저는 이를 스크립트 코드로 인식함. HTML5부터 태그에 type이나 language 속성을 지정할 필요가 없음 언어적 특징 컴파일이 아닌 인터프리터 방식 프로그램 작성 측면에서 보다 쉽고 빠르나, 컴파일 언어보다 제한된 능력과 실행 속도를 가짐 타입 체크가 느슨함. 너무 유연하기 때문에 예상치 못한 부작용 발생 가능성 높음 객체 지향보다는 객체 기반 node.js처럼 점차 서버쪽으로 영역이 커지고 있음 스크립트의 위치 스크립트를 별도 파일로 분리하고 참조하는 방식이 일반적 head태그에 작성된 코드가 먼저 실행되고 body 태그에 작성된 코드가 실행된다. 에러처리 인터프리터 방식이기 때문에 브라우저는 잘못된 스크립트 코드를 만나면 그냥 무시하고 리턴한다. 어휘 구조 문장 내의 공백과 탭은 무시한다. HTML과 달리 대소문자를 구분한다. 문장과 문장은 세미콜론으로 구분 스크립트 코드 내에서 HTML 주석은 사용하면 안된다. 출력 자바스크립트는 자체 출력 함수를 가지고 있지 않음 대신 내장 객체를 사용하여 출력을 할 수 있으며, 주로 console.log()를 많이 사용한다. 대화상자 실행을 블록 시키기 때문에 사용을 지양해야함. window.alert(message),window.prompt(message),window.confirm(message) 엄격모드 자바스크립트의 유연한 문법 이면의 애매함에 의한 부작용을 막기 위해 도입(ES5) 스크립트 선두나 함수 선두에 use strict구문을 작성해서 사용 변수를 선언하지 않고 사용할 수 없음 일반 함수에서 this는 전역 객체가 아닌 undefined가 됨 변수 원시형 Numbers 한 종류의 숫자 타입만 가짐 Strings 연속된 문자들 Booleans true or false 객체형 object {}(curly brace)로 표현 function 함수 자체도 데이터 타입 undefined 값이 없는 변수 숫자 자바스크립트에서 숫자 타입은 항상 64비트 부동 소수점 52 비트의 상수, 11비트의 소수점, 1bit의 부호로 구성된다. 정수는 15자리까지 표현이 가능하다. 소수는 17자리까지 표현이 가능하나 항상 정확한건 아님 0x로 시작하여 16진수 값을 표현 가능 문자열 연속된 문자들을 \u0026quot; 또는 \u0026lsquo;로 둘러싸서 표현 가능 논리형 true 혹은 false값을 표현함 자바스크림트에서 값이 없는 모든것은 false 0(zero), -0(minus zero), \u0026ldquo;\u0026quot;(empty value),undefined,null,NaN 변수의 선언 자바스크립트에서는 변수 선언 시 타입을 지정하지 않음 필요한 변수들을 모두 스크립트 시작 부분에 선언하는 것이 올바른 습관임. 선업 없이 사용하기 인터프리터 방식이라는 특징 때문에 변수를 선언하지 않고 사용할 수 있음. 변수의 타입 또한 언제든지 바꿀수 있음. 변수의 범위 scope는 접근할 수 있는 변수, 객체, 함수의 집합으로 자바스크립트는 function scope이다. 로컬 변수는 함수가 종료되면 소멸되며, 글로벌 변수는 페이지가 종료되면 소멸됨. global에 var 키워드를 사용하지 않으면 자동으로 전역 변수가 됨.(???) 상수 const 키워드를 사용한다. 관습적으로 대문자 + underscore로 명명한다 특수한 값 자바스크립트는 특수한 상태를 표현하는 리터럴을 제공한다. null 변수가 선언되지 않은 상태 undefined 변수가 선언되었지만 값이 초기화 되지 않은 상태 (예: var x;) Empty Values 변수가 선언되었고 빈 값으로 초기화된 상태 (예:var x =\u0026quot;\u0026quot;;) Infinity(or -Infinity) 무한대를 나타내는 상수로 숫자 타입임(예:var x=2/0; var y=-2/0;) NaN(Not a Number) 숫자로 표현할 수 없는 상수로 숫자 타입임(예:var x=0/0; var y=0/\u0026quot;A\u0026quot;;) 암시적 변환 자바스크립트에서 서로 다른 데이터 타입의 값을 연산하면 실행 중에 자동으로 타입을 바꿔 적용함 \u0026quot;8\u0026quot; + \u0026quot;6\u0026quot; ==\u0026gt; \u0026quot;86\u0026quot; , \u0026quot;8\u0026quot; - \u0026quot;6\u0026quot; ==\u0026gt; 2 명시적 변환 명시적으로 형 변환을 해야 하는 경우에는 타입 별로 정의된 내장 함수를 사용한다. Number(\u0026quot;82\u0026quot;) + Number(\u0026quot;75\u0026quot;) ==\u0026gt; 157 숫자를 문자열로 변환 String(320 + 160) ==\u0026gt; \u0026quot;480\u0026quot; 논리형의 변환 Boolean(\u0026quot;false\u0026quot;) ==\u0026gt; false 연산자 기본적으로 자바와 유사함. 특별한 연산자를 살펴본다. 대입 연산자 36 = 9 \u0026lt;\u0026lt; 2; 왼쪽으로 시프트, 오른쪽으로 0을 추가함 2 = 9 \u0026gt;\u0026gt; 2; 오른쪽으로 시프트, 왼쪽의 비트가 사라짐 4 = 19 \u0026gt;\u0026gt;\u0026gt;2 오른쪽으로 시프트, 왼쪽의 비트를 0으로 채움 증감 연산자 전위형은 값을 먼저 증가시키고 반환하며, 후휘형은 값을 먼저 반환하고 증가시킴. 비교 연산자 일반적으로 자바와 같으면 아래 동등 비교 연산자가 드라다. == 좌변과 우변의 값이 같다. === 좌변과 우변의 값과 타입이 같다. 논리 연산 Short Circuit 기능을 제공함. 앞의 조건이 참인 경우에만 뒤의 조건을 평가. typeof 자바스크립트의 동적인 타입을 typeof 연산자를 통해 실쟁 중에 어떤 타입인지 검사할 수 있음. 제어문 일반적으로 자바와 같음 점프문 break 문은 label과 함께 쓰면 다중 루프도 빠져나올 수 있음. break endloop; endloop: 무한루프 for(;;)처럼 for문의 조건을 생략하거나, while(true)를 통해 무한루프를 작성할 수 있다. 예외구문 자바처럼 try ~ catch ~ finally 구문을 사용함. 예외 발생시 catch 블록으로 exception 객체가 전달 됨. 함수 함수의 정의 함수는 특정 일을 수행하는 코드 블록에 이름을 붙여 정의한 객체 1// 선언 - 리턴 타입을 명시하지 않으나 필요하다면 본체에서 리턴 가능 2function functioName(param1, param2,...){ 3 code to be excuted 4} 5 6// 호출,만약 함수 선언이 호출보다 뒤에 있더라도 hoisting에 의해 실행에 문제가 없다. 7functionname(p1,p2); hoisting은 인터프리터가 자바스크립트 코드를 해석함에 있어서 Global 영역에 선언된 코드 블록을 최상위 Scope로 끌어올리는것을 말한다. 인수 함수의 인수는 자바와 달리 타입이 없다. 인수의 개수가 호출 구문과 일치하지 않아도 실행됨. 명시적인 인수 외에 묵시적인 arguments라는 인수의 배열이 자동으로 전달됨 인수 전달 방식 원시형 타입(Numbers,Strings,Booleans)는 값으로 전달(call by value) 객체는 참조로 전달 (call by reference) 리턴값 별도의 return문을 사용하지 않으면 undeifned가 반환 됨 내부함수 함수 안에 정의한 함수를 말하며, 중첩함수라고도 한다. 익명함수 함수를 선언한 후 사용하지 않고 표현식처럼 사용할 수 있다.(이름이 없는 함수) 1var add = function(a,b){ 2 return a + b; 3}; 4add(2,3); 익명함수는 hoisting 되지 않는다. 명시적으로 선언을 가장 위에 써둬야함. 클로저 클로저는 지역 변수의 범위를 확장하는 자바스크립트의 기법 전역 변수가 필요하지만 이름 충돌 등의 이유로 지역 변수로 내려 사용하면서도 변수가 유지되게 하고 싶을 때 사용 1function outer(){ 2 var value = 1234; 3 function inner(){ 4 document.write(value); 5 } 6 return inner; 7} 8 9var outin = outer(); 10outin(); // 1234 동적함수 동적함수는 실행 중에 본체가 정의된다. 1var body; 2if(confirm(\u0026#34;더할래,곱할래\u0026#34;) == true){ 3 body = \u0026#34;return a +b;\u0026#34;; 4}else { 5 body = \u0026#34;return a * b\u0026#34;; 6} 7 8var add = new Function(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,body); 9document.write(\u0026#34;result = \u0026#34; + add(2,3) + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;); 내장 함수 parseInt(value),Number(\u0026quot;0x1a\u0026quot;)와 같은 타입 변환 내장함수를 제공함. isNan(value)와 같은 상태점검 내장함수를 제공함 encodeURI(uri)와 같은 인코딩 내장함수를 제공함 객체 객체의 선언 객체는 변수들을 담고 있는 변수이다. 원시 타입(strings,numbers 등)의 값을 제외하면 모든 값은 객체다. 1// 리터럴 방식 (권장) 2var person = { 3 firstName:\u0026#34;John\u0026#34;, 4 lastName:\u0026#34;Doe\u0026#34; 5}; 6// new 연산자 방식 7var person = new Object(); 8person.firstName =\u0026#34;John\u0026#34;; 9person.lastName = \u0026#34;Doe\u0026#34;; 멤버의 참조 .이나 [] 연산자로 참조 가능하다. 1//objectName.property; 2person.age; 3//objectName[\u0026#34;property\u0026#34;]; 4person[\u0026#34;age\u0026#34;]; with 임시로 변수의 유효범위 체인을 변경하는데 사용되며 객체의 멤버를 참조하는 코드를 간결하게 할 수 있다. 다만 with는 코드가 모호해지고 성능이 떨어지기 때문에 엄격모드에서는 에러로 처리된다. (가능하면 사용을 자제하자) 1var person = {age:50}; 2var age = 30; 3with(person){ 4 document.write(age); // age 판단하기 어려워짐 5} 값과 참조 자바스크립트 원시 타입의 변수는 값으로 참조되는 반면 객체의 변수는 레퍼런스로 참조됨 자바스크립트 원시 타입은 immutable하고 객체는 mutable함 1var y = 1; 2var x = y; // 값 참조 3 4var person = {firstName:\u0026#34;John\u0026#34; , lastName:\u0026#34;Doe\u0026#34;}; 5var x = person // 레퍼런스 6x.age = 10; // person도 함께 변경됨 메소드 자바스크립트 메소드는 객체에서 수행할 수 있는 동작을 지정하며 함수의 정의를 담고 있는 속성임 메소드는 함수가 객체 타입의 속성으로 담겨 있는 것임 1var person = { 2 firstName:\u0026#34;John\u0026#34; , 3 lastName:\u0026#34;Doe\u0026#34;, 4 fullName:function() { return this.firstName +\u0026#34; \u0026#34; + this.lastName;} 5}; 6person.fullName(); // 괄호를 생략하면 단순 메소드의 정보를 보여줌 동적 속성 편집 객체의 멤버는 실행 중에 마음대로 추가,삭제할 수 있다. 1var person = { 2 firstName:\u0026#34;John\u0026#34; , 3 lastName:\u0026#34;Doe\u0026#34; 4}; 5delete person.lastName; 클래스 생성자 방식은 다른 언어들의 클래스와 기능적으로 유사 생성되는 객체별로 복사본을 갇도록 하기위해 this를 사용 1function person(first, last,age,eyecolr){ 2 this.first = first; 3 this.last = last; 4 this.age = age; 5 this.eyecolor = eyecolor; 6} 7var myFather = new person(\u0026#34;John\u0026#34;,\u0026#34;Doe\u0026#34;,50,\u0026#34;blue\u0026#34;); 8var myMother = new person(\u0026#34;Sally\u0026#34;,\u0026#34;Rally\u0026#34;,48,\u0026#34;green\u0026#34;); 프로토타입 프로토타입은 생성자를 통해 생성된 객체들 사이에 공유되는 영역 1function person(first, last,age,eyecolr){ 2 this.first = first; 3 this.last = last; 4 this.age = age; 5 this.eyecolor = eyecolor; 6} 7// person의 모든 인스턴스가 name이라는 function을 가지게된다 8person.prototype.name = function(){ 9 return this.first + \u0026#34; \u0026#34; + this.last; 10} instanceof 연산자 instanceof 연산자는 객체가 특정 생성자로 만들어진건지 체크 상위 클래스도 체크하기 때문에 최상위 객체인 Object로 체크하면 항상 참이 나옴 1function Person(name){ 2 this.name = name; 3} 4function Car(model){ 5 this.model = model; 6} 7var p = new Person(\u0026#34;John Doe\u0026#34;); 8var c = new Car(\u0026#34;50\u0026#34;); 9 10if(c instanceof Person) document.write(c); // 거짓 this java와 유사함. 실행 문맥에 따라 의미가 달라짐 메소드 내부의 this는 해당 메소드를 호출한 부모 객체를 참조 생성자 함수 코드 내부의 this는 새로 생성된 객체를 참조 call(),apply() 문맥에 따라 변하는 this를 내가 원하는 객체로 바꾸기 위해 사용한다. call()은 각각 하나의 인자로 넘기고, apply()는 배열 형태로 인자를 넘김 원시객체 Object 자바스크립트 최상위 객체로 모든 객체는 Object의 속성을 사용 가능 var x = {};와 같이 리터럴 방식 사용 권장 constructor,toString(),valueOf()등이 있음 Number Number 객체는 원시 타입의 숫자 형을 표현하는 자바스크립트 내장 객체 var x = new Number() 보단 var x = 0;을 권장 MAX_VALUE,toFixed(x)등이 있음 String String 객체는 원시 타입의 문자형을 표현하는 자바스크립트 내장 객체 var x = new String()대신 var x =\u0026quot;\u0026quot;을 권장 \u0026quot;koread\u0026quot;.length 등이 있음 Boolean Boolean 객체는 원시 타입의 논리형을 표현하는 자바스크립트 내장 객체 var x = new Boolean();대신 var x = false;를 권장 Object로 상속 받은 속성 외에 별도의 멤버가 없음 래퍼 객체 자바스크립트는 원시 데이터 타입에 대응되는 내장 객체들을 제공하지만 가급적 객체 형태 보다는 원시 데이터 타입을 권장한다. 1var a = new String(\u0026#34;korea\u0026#34;); 2var b = \u0026#34;korea\u0026#34;; 3// a == b =\u0026gt; true 4// a === b =\u0026gt; false 5// typeof(a) == typeof(b) =\u0026gt; false 6// a.constructor == b.constructor =\u0026gt; true 속성 설명자 Object.defineProperty() 내장 함수는 객체에 속성을 다양한 옵션으로 정의할 수 있는 방법을 제공한다. 1var person = { 2 name : \u0026#34;John Doe\u0026#34;, 3 eyeColor : \u0026#34;blue\u0026#34; 4}; 5// 속성 설명자 6Object.defineProperty(person,\u0026#34;age\u0026#34;,{ 7 value :50, 8 enumerable :false, // for in 문으로 열거 가능 여부 9 writable :false // 값 변경가능 여부 10}) 액세서 java의 getter와 setter의 역할을 한다고 보면된다. 1var person = { 2 name : \u0026#34;John Doe\u0026#34;, 3 age : 50 4}; 5 6Object.defineProperty(person,\u0026#34;age\u0026#34;,{ 7 enumerable :true, // for in 문으로 열거 가능 여부 8 get : function{return age;} // 액세서 9 set : function(value){ // 액세서 10 if(value \u0026gt; -1) { age = value;} 11 } 12}) 객체 생성 객체를 리터럴로 생성하는 경우에는 속성의 이름과 값만 지정 가능하기 떄문에 속성의 옵션까지 적용하려면 Object.create() 내장 함수를 사용해야 함 Object.create()를 통해 상속을 구현할 수도 있음 1// 문법 Object.create(원본객체, 설명자 집합) 2var person = Object.create({},{ 3 name :{ 4 value : \u0026#34;John Doe\u0026#34; 5 } 6}); 7 8var staff = Object.create(person,{ 9 salary:{ 10 value : 680 11 } 12}); 캡슐화 속성의 추가나 삭제를 금지 또는 허용 preventExtensions()를 통해 필드 추가를 방지 freeze()를 통해 필드 삭제나 추가를 하지 못하도록 함 배열 배열도 자바스크립트의 내장 객체 중 하나 배열의 선언 생성자 방식 1Array(n); 리터럴 방식 1var ar = [1,2,3,4,5]; 배열의 특성 다른 언어의 배열에 비해 독특한 특징들이 있음 배열의 크기는 가변적이며 실행 중에 필요한 만큼 늘어남 배열의 인덱스가 꼭 연속적일 필요는 없음 문자열의 length와 달리 배열의 length 속성은 직접 변경 가능 배열의 인덱스가 반드시 정수를 사용하지 않아도 됨 배열의 순회 배열의 동적 특성 때문에 for(var 변수 in 배열){} 순회가 더 안전하다 배열의 배열 다른 언어처럼 다차원 배열이 가능함 유사배열 배열은 객체인데 역으로 객체를 배열과 유사하게 사용하는 경우도 있음 이 경우 length 속성을 추가한다 하더라도 배열처럼 자동으로 관리되지 않음 Array 메소드 indexOf(item,start)나 push(a)같은 내장 메소드 사용이 가능함 추가 및 삭제 push와 pop (stack처럼 동작) unshift와 shift (queue처럼 동작) splice(index,cnt,item1,...)는 특정 위치에서 원하는 개수만큼 요소를 추가 및 제거 분리 및 합침 slice(start,end)는 배열의 일부를 복사해 새 배열을 만듦 concat(arr)은 배열을 합쳐 하나로 만듦 정렬 sort(comparefn)는 배열의 요소를 크기 순으로 정렬하며 comparefn을 지정하지 않으면 사전순으로 비교하여 요소의 길이가 고려되지 않음 reverse()는 배열의 순서를 반대로 바꿈 순회 메소드 forEach(callbackfn) 메소드는 배열을 순회하면서 요소의 값을 반환 map(callbackfn) 메소드는 배열을 순회하면서 원본 배열의 요소를 받아 새로운 배열을 만들어 반환 내장객체 String 내장객체 문자열 조작과 관련된 각종 기능들을 제공한다. charAt(index), replace(searchValue,newValue)등이 있다. 변경 toUpperCase(), toLowerCase(),trim()이 있다. 추출 substring(start,end) , substr(start,length),slice(start,end)등이 있다 코어객체 Math,Date,RegExp,JSON,Audio 등이있다. BOM Browser Object Model의 약자 언어 자체적으로 제공하는 내장 객체와 달리 브라우저 별로 약간씩 상이하기 떄문에 고수준 라이브러리를 많이 사용한다 Window BOM의 최상위 객체는 Window이다. 브라우저 실행과 동시에 생성된다. 주요 속성으로 name,status등이 있다. 주요 메소드로 closed(),focus()등이 있다. Window를 포함하는 몇가지 객체가 있다. history 객체는 방문한 URL 목록을 저장하고 관리함 location 객체는 현재 방문중인 페이지의 URL의 속성들을 가지고 있음 screen 객체는 사용자의 화면에 대한 정보를 제공함 navigator 객체는 브라우저와 운영체제에 대한 정보를 제공함 DOM Document Object Model의 약자 DOM은 HTML 문서를 읽고 조작하는 객체의 집합 BOM과 마찬가지로 자바스크립트 관점에서 Built-in Object가 아닌 Host Object 찾기 document.getElementById(id);와 같은 문법 사용 읽기, 쓰기 innerHTML,innerText와 같은 문법 사용 노드 추가 appendChild(node)와 같은 문법 사용 속성 추가 setAttribute(name,value)와 같은 문법 사용 삭제 removeChild(node)와 같은 문법 사용 이벤트 모델 load,unload 페이지 시작 및 종료 click,mousedown등과 같은 다양한 이벤트 핸들러가 있다. 기본 모델과 인라인 모델 기본모델의 경우 getElementById()를 통해 노드를 가져와서 노드의 onclick에 이벤트 처리 function을 부여하는 방식 인라인 모델은 노드의 속성인 onclick에 바로 function 명을 작성하는 방식 리스너 등록 DOM 레벨 2에서 도입된 방식으로 가장 널리 쓰임. addEventListener(type,listener,useCapture) 문법을 사용 예) header.addEventListener('click',headerClick2); 이벤트 인수 이벤트 발생 시 핸들러의 첫 번째 인수로 event 객체가 전달되고, 객체 안에는 추가 정보가 담겨있음(this도 함께 전달됨) 이벤트 호출 이벤트도 함수이므로 이벤트가 사용자에 의해 발생되지 않아도 직접 호출이 가능함 이벤트 무시 핸들러에서 false를 반환하면 이벤트가 무시됨 이벤트 버블링 여러 객체에 동시에 발생한 이벤트 처리를 위해 버블링과 캡처링을 사용함 버블링 자식이 이벤트를 먼저 받고 이어서 부모가 이벤트를 받음(말단에서 body로) 캡쳐링 부모가 이벤트를 먼저 받고 아래쪽 자식으로 전파됨(body에서 말단으로) addEventListener(type,listener,useCapture)의 세번째 인자로 제어하거나, stopPropagation()으로 이벤트 전파 차단 가능 load HTML 문서가 로드를 완료 했을때 발생 resize 브라우저의 크기가 변할 때 마다 발생 마우스 이벤트 마우스 이벤트는 엘리먼트 위에서 마우스를 조작할 때 발생 AJAX AJAX(Asynchronous JavaScript and XML)은 화면 전환 없이 서버와 통신할 수 있도록 하기 위해 기존 기술을 조합한 새로운 웹 개발 접근 방식 ","permalink":"https://92SooJong.github.io/posts/javascript/javascript-%EA%B8%B0%EC%B4%88/","summary":"Javascript 개요 역사 Brendan Eich에 의해 1995년에 만들어졌으며 1997년에 ECMA 표준이되었다. 모카 -\u0026gt; 라이브스크립트 -\u0026gt; 자바스크립트 -\u0026gt; ECMA스크립트 현재는 ECMAScript6가 작업중 script 태그 script 태그를 만나면 브라우저는 이를 스크립트 코드로 인식함. HTML5부터 태그에 type이나 language 속성을 지정할 필요가 없음 언어적 특징 컴파일이 아닌 인터프리터 방식 프로그램 작성 측면에서 보다 쉽고 빠르나, 컴파일 언어보다 제한된 능력과 실행 속도를 가짐 타입 체크가 느슨함. 너무 유연하기 때문에 예상치 못한 부작용 발생 가능성 높음 객체 지향보다는 객체 기반 node.","title":"Javascript 기초"},{"content":"정의 Call by value(값에 의한 호출)는 인자로 받은 값을 복사하여 처리를 한다. 안전한 방법이며, 메모리 사용량은 Call by reference보다 많다. Call by reference(참조에 의한 호출)는 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다. 직접 참조하기때문에 속도, 메모리면에서 Call by value에 비해 이점이 있으나, 값 변경의 위험이 있다. 간단히 말해 값을 복사를 하여 처리를 하느냐, 아니면 직접 참조를 하느냐 차이인 것이다. 예제코드 1package com.company; 2 3public class Main { 4 5 private static class User{ 6 String name; 7 public User(String name){this.name = name;}; 8 9 public void setName(String name) {this.name = name;} 10 public String getName() {return name;} 11 } 12 13 public static void main(String[] args){ 14 15 // call by value 16 int n = 10; 17 func(n); 18 System.out.println(\u0026#34;func(n) = \u0026#34; + n); 19 20 // call by reference 21 // 자바에서는 주소를 가져올 방법이 없기때문에 call by reference가 불가능하다. 22 23 // 객체 프로퍼티 접근 24 User sampleUser = new User(\u0026#34;soojong\u0026#34;); 25 26 // call by reference처럼 동작하나 사실 주소\u0026#34;값\u0026#34;을 복사해서 넘기는것이다. 27 // 즉, 주소값 자체를 넘기는 call by reference와는 다르다. 28 foo(sampleUser); 29 System.out.println(\u0026#34;sampleUser = \u0026#34; + sampleUser.getName()); 30 31 } 32 33 static void func(int n) { 34 n = 20; 35 } 36 37 public static void foo(User user){ 38 user.setName(\u0026#34;Joey\u0026#34;); 39 40 } 41 42} ","permalink":"https://92SooJong.github.io/posts/java/call-by-value%EC%99%80-call-by-reference/","summary":"정의 Call by value(값에 의한 호출)는 인자로 받은 값을 복사하여 처리를 한다. 안전한 방법이며, 메모리 사용량은 Call by reference보다 많다. Call by reference(참조에 의한 호출)는 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다. 직접 참조하기때문에 속도, 메모리면에서 Call by value에 비해 이점이 있으나, 값 변경의 위험이 있다. 간단히 말해 값을 복사를 하여 처리를 하느냐, 아니면 직접 참조를 하느냐 차이인 것이다. 예제코드 1package com.company; 2 3public class Main { 4 5 private static class User{ 6 String name; 7 public User(String name){this.","title":"Call-by-value와 Call-by-reference.md"},{"content":"최초셋팅 테스트를 위한 README 파일 생성 echo \u0026quot;# git_tutorial\u0026quot; \u0026gt;\u0026gt; README.md 현재 위치를 로컬 저장소로 설정함. 즉, repository를 받아올수 있는 상태 git init 변경된 사항을 준비영역에 추가함 git add README.md 준비영역의 파일들을 로컬 저장소로 옮긴다 git commit -m \u0026quot;first commit\u0026quot; 로컬 저장소와 원격저장소를 연결한다. git remote add origin https://github.com/92SooJong/git_tutorial.git 로컬의 커밋이력을 원격 master브랜치에 반영한다. git push -u origin master 설정 commit 시에 사용할 username과 email 설정 git config --global user.name \u0026quot;your_name\u0026quot; git config --global user.email \u0026quot;your_email@example.com\u0026quot; 기본 원격 저장소의 변경사항을 받아온다 git pull origin master init 명령을 취소한다. 로컬 저장소 기능 제거 rm -r .git 현재 경로 파일 준비영역에 추가 git add . add 된 파일 로컬 저장소에 저장 git commit hello 메세지를 달고 로컬 저장소에 저장 git commit -m \u0026quot;hello\u0026quot; 로컬 저장소 파일을 원격 저장소로 push git push -u origin master staging 변경 내역조회 git status Branch 브랜치 생성 git branch [브랜치명] 브랜치 이동 git checkout [브랜치명] 브랜치 병합 git merge [브랜치명] ( 현재 HEAD가 가르키고 있는 브랜치에 [브랜치명]을 흡수함 ) ","permalink":"https://92SooJong.github.io/posts/git/%EB%AA%85%EB%A0%B9%EC%96%B4/","summary":"최초셋팅 테스트를 위한 README 파일 생성 echo \u0026quot;# git_tutorial\u0026quot; \u0026gt;\u0026gt; README.md 현재 위치를 로컬 저장소로 설정함. 즉, repository를 받아올수 있는 상태 git init 변경된 사항을 준비영역에 추가함 git add README.md 준비영역의 파일들을 로컬 저장소로 옮긴다 git commit -m \u0026quot;first commit\u0026quot; 로컬 저장소와 원격저장소를 연결한다. git remote add origin https://github.com/92SooJong/git_tutorial.git 로컬의 커밋이력을 원격 master브랜치에 반영한다. git push -u origin master 설정 commit 시에 사용할 username과 email 설정 git config --global user.name \u0026quot;your_name\u0026quot; git config --global user.","title":"명령어"},{"content":"정의 JIT(Just-In-Time) 컴파일러는 두 가지의 방식을 혼합한 방식으로 생각할 수 있는데, 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.\nJVM에서 자바 프로그램코드를 기계어로 변환하는 과정 자바 프로그램코드 -\u0026gt; 바이트코드 -\u0026gt; 바이트코드 실행시에 JIT 컴파일 수행 -\u0026gt; 기계어\n설명 바이트 코드는 기계어는 아니지만 가상 머신에 의해 기계어로 손쉽게 변환할 수 있는 코드다. JIT 컴파일러는 바이트 코드를 읽어 빠른속도로 기계어를 생성한다. ( 코드가 실행되는 과정에서 실시간으로 진행 됨 ) JIT 컴파일러는 전체 코드의 필요한 부분만 변환한다. 불필요한 부분은 캐싱으로 처리하기 때문에 재번역하는 일이 없다. 일반적인 인터프러터 언어(예시: cpython)는 바이트코드나 소스코드를 최적화 과정이 없이 번역하기 때문에 성능이 낮다. 반면 정적으로 컴파일하는 언어(예시: c 언어)는 실행 전에 무조건 컴파일을 해야하기 때문에 다양한 플랫폼에 맞게 컴파일을 하려면 시간이 오래 걸린다. ","permalink":"https://92SooJong.github.io/posts/java/just-in-time/","summary":"정의 JIT(Just-In-Time) 컴파일러는 두 가지의 방식을 혼합한 방식으로 생각할 수 있는데, 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.\nJVM에서 자바 프로그램코드를 기계어로 변환하는 과정 자바 프로그램코드 -\u0026gt; 바이트코드 -\u0026gt; 바이트코드 실행시에 JIT 컴파일 수행 -\u0026gt; 기계어\n설명 바이트 코드는 기계어는 아니지만 가상 머신에 의해 기계어로 손쉽게 변환할 수 있는 코드다. JIT 컴파일러는 바이트 코드를 읽어 빠른속도로 기계어를 생성한다.","title":"Just In Time"},{"content":"클래스 클래스내부에 있는 클래스에는 두가지 유형이 있는데 하나는 Static 키워드가 붙어있는 클래스이고, 다른 하나는 Static 키워드가 없는 클래스이다.\n두가지 유형을 일반적으로 아래처럼 명명해서 사용중이다. None Static Class는 inner class Static Class는 static nested class static nested class static nested class는 자신을 감싸고 있는 클래스를 통해서 접근이 가능하다. Top-Class의 인스턴스를 사용하지 않고도 nested class를 사용할 수 있다. 외부의 필드에 static 키워드가 없다면 접근이 불가능하다. 외부 클래스의 인스턴스를 통해서 접근해야한다. 클래스의 역할은 인스턴스를 만드는 \u0026lsquo;설계도\u0026rsquo;의 역할을 할 뿐이고, static 클래스라고해서 인스턴스가 만들어져 있는게 아니다. 단지 아래처럼 인스턴스를 만드는 방식에 약간의 차이가 있을뿐이다. ( static class는 자신을 감싸고 있는 클래스의 인스턴스가 필요없음!) 1OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass(); inner class inner class는 반드시 외부 클래스의 인스턴스를 통해서만 인스턴스 생성이 가능하다. 이런 경우 inner class의 인스턴스는 외부 인스턴스에 대해 참조를 가지고 있다. ( 인스턴스간의 연결이 발생함 ) 이를 외부참조 또는 숨은 외부참조라고 부른다. 외부참조 덕분에 innser class 인스턴스에서 외부 클래스의 인스턴스 필드에 접근이 가능하다. 1OuterClass outerObject = new OuterClass() 2OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 단점 참조값을 담아야 하기 때문에, 인스턴스 생성시 시간적, 공간적으로 성능이 낮아진다. 외부 인스턴스에 대한 참조가 존재하기 때문에, 가비지 컬렉션이 인스턴스 수거를 하지 못하여 메모리 누수가 생길 수 있다. ","permalink":"https://92SooJong.github.io/posts/java/static/","summary":"클래스 클래스내부에 있는 클래스에는 두가지 유형이 있는데 하나는 Static 키워드가 붙어있는 클래스이고, 다른 하나는 Static 키워드가 없는 클래스이다.\n두가지 유형을 일반적으로 아래처럼 명명해서 사용중이다. None Static Class는 inner class Static Class는 static nested class static nested class static nested class는 자신을 감싸고 있는 클래스를 통해서 접근이 가능하다. Top-Class의 인스턴스를 사용하지 않고도 nested class를 사용할 수 있다. 외부의 필드에 static 키워드가 없다면 접근이 불가능하다. 외부 클래스의 인스턴스를 통해서 접근해야한다. 클래스의 역할은 인스턴스를 만드는 \u0026lsquo;설계도\u0026rsquo;의 역할을 할 뿐이고, static 클래스라고해서 인스턴스가 만들어져 있는게 아니다.","title":"Static"},{"content":" 1//////////////////////// Phone.java 2public class Phone{ 3 4 private String name; 5 private String realeseDate; 6 private String companyName; 7 private boolean isAndroid; 8 private boolean isKoreaCompany; 9 10 public static class Builder{ 11 12 private String name; 13 private String realeseDate; 14 private String companyName; 15 private boolean isAndroid; 16 private boolean isKoreaCompany; 17 18 public Builder name(String name){ 19 this.name = name; 20 return this; 21 } 22 public Builder realeseDate(String realeseDate){ 23 this.realeseDate = realeseDate; 24 return this; 25 } 26 public Builder companyName(String companyName){ 27 this.companyName = companyName; 28 return this; 29 } 30 public Builder isAndroid(boolean isAndroid){ 31 this.isAndroid = isAndroid; 32 return this; 33 } 34 public Builder isKoreaCompany(boolean isKoreaCompany){ 35 this.isKoreaCompany = isKoreaCompany; 36 return this; 37 } 38 39 public Phone buildInstance(){ 40 return new Phone(this); 41 } 42 43 } 44 45 private Phone(Builder builder){ 46 this.name = builder.name; 47 this.realeseDate = builder.realeseDate; 48 this.companyName = builder.companyName; 49 this.isAndroid = builder.isAndroid; 50 this.isKoreaCompany = builder.isKoreaCompany; 51 } 52 53 public String getName() { 54 return name; 55 } 56 57 public String getRealeseDate() { 58 return realeseDate; 59 } 60 61 public String getCompanyName() { 62 return companyName; 63 } 64 65 public boolean isAndroid() { 66 return isAndroid; 67 } 68 69 public boolean isKoreaCompany() { 70 return isKoreaCompany; 71 } 72} 73 74//////////////////////// Main.java 75public class Main { 76 77 public static void main(String[] args){ 78 79 Phone iphone = new Phone.Builder() 80 .companyName(\u0026#34;apple\u0026#34;) 81 .name(\u0026#34;Iphone13\u0026#34;) 82 .isKoreaCompany(false) 83 .isAndroid(false) 84 .realeseDate(\u0026#34;2021\u0026#34;) 85 .buildInstance(); 86 87 System.out.println(\u0026#34;iphone.getName() = \u0026#34; + iphone.getName()); 88 System.out.println(\u0026#34;iphone.getCompanyName() = \u0026#34; + iphone.getCompanyName()); 89 90 } 91} ","permalink":"https://92SooJong.github.io/posts/design-pattern/joshua-builderpattern/","summary":"1//////////////////////// Phone.java 2public class Phone{ 3 4 private String name; 5 private String realeseDate; 6 private String companyName; 7 private boolean isAndroid; 8 private boolean isKoreaCompany; 9 10 public static class Builder{ 11 12 private String name; 13 private String realeseDate; 14 private String companyName; 15 private boolean isAndroid; 16 private boolean isKoreaCompany; 17 18 public Builder name(String name){ 19 this.name = name; 20 return this; 21 } 22 public Builder realeseDate(String realeseDate){ 23 this.","title":"Joshua의 BuilderPattern"},{"content":" 1//////////////////////////////////// PhoneBuilder.java 2public interface PhoneBuilder { 3 4 5 void buildName(); 6 void buildRealeseDate(); 7 void buildCompanyName(); 8 void buildIsAndroid(); 9 void buildIsKoreaCompany(); 10 Phone getPhone(); 11 12} 13 14//////////////////////////////////// Iphone13Builder.java 15public class Iphone13Builder implements PhoneBuilder{ 16 17 private Phone phone; 18 19 public Iphone13Builder() { 20 this.phone = new Phone(); 21 } 22 23 @Override 24 public void buildName() { 25 phone.setName(\u0026#34;Iphone13\u0026#34;); 26 } 27 28 @Override 29 public void buildRealeseDate() { 30 phone.setCompanyName(\u0026#34;202110\u0026#34;); 31 } 32 33 @Override 34 public void buildCompanyName() { 35 phone.setCompanyName(\u0026#34;apple\u0026#34;); 36 } 37 38 @Override 39 public void buildIsAndroid() { 40 phone.setIsAndroid(false); 41 } 42 43 @Override 44 public void buildIsKoreaCompany() { 45 phone.setIsKoreaCompany(false); 46 } 47 48 @Override 49 public Phone getPhone() { 50 return this.phone; 51 } 52} 53 54//////////////////////////////////// Phone.java 55public class Phone{ 56 57 private String name; 58 private String realeseDate; 59 private String companyName; 60 private boolean isAndroid; 61 private boolean isKoreaCompany; 62 63 // setter와 getter를 만든다 64 public void setName(String name) { 65 this.name = name; 66 } 67 68 public void setRealeseDate(String realeseDate) { 69 this.realeseDate = realeseDate; 70 } 71 72 73 public void setCompanyName(String companyName) { 74 this.companyName = companyName; 75 } 76 77 78 public void setIsAndroid(boolean isAndroid) { 79 this.isAndroid = isAndroid; 80 } 81 82 83 public void setIsKoreaCompany(boolean isKoreaCompany) { 84 this.isKoreaCompany = isKoreaCompany; 85 } 86 87 88 public String getName() { 89 return name; 90 } 91 92 public String getRealeseDate() { 93 return realeseDate; 94 } 95 96 public String getCompanyName() { 97 return companyName; 98 } 99 100 public boolean isAndroid() { 101 return isAndroid; 102 } 103 104 public boolean isKoreaCompany() { 105 return isKoreaCompany; 106 } 107} 108 109//////////////////////////////////// Director.java 110 111public class Director { 112 113 private PhoneBuilder phoneBuilder; 114 115 public Director(PhoneBuilder phoneBuilder) { 116 this.phoneBuilder = phoneBuilder; 117 } 118 119 public Phone getPhone(){ 120 return this.phoneBuilder.getPhone(); 121 } 122 123 public void makePhone(){ 124 this.phoneBuilder.buildName(); 125 this.phoneBuilder.buildCompanyName(); 126 this.phoneBuilder.buildRealeseDate(); 127 this.phoneBuilder.buildIsAndroid(); 128 this.phoneBuilder.buildIsKoreaCompany(); 129 130 } 131 132} 133 134 135//////////////////////////////////// Main.java 136 137public class Main { 138 139 public static void main(String[] args){ 140 141 PhoneBuilder iphoneBuilder = new Iphone13Builder(); // 아이폰13 빌더 142 Director director = new Director(iphoneBuilder); // 지시자에게 주입 143 director.makePhone(); // 지시 144 Phone madePhone = director.getPhone(); // 완성품 145 146 System.out.println(\u0026#34;madePhone.getName() = \u0026#34; + madePhone.getName()); 147 System.out.println(\u0026#34;madePhone.getCompanyName() = \u0026#34; + madePhone.getCompanyName()); 148 } 149} ","permalink":"https://92SooJong.github.io/posts/design-pattern/gof-builderpattern/","summary":"1//////////////////////////////////// PhoneBuilder.java 2public interface PhoneBuilder { 3 4 5 void buildName(); 6 void buildRealeseDate(); 7 void buildCompanyName(); 8 void buildIsAndroid(); 9 void buildIsKoreaCompany(); 10 Phone getPhone(); 11 12} 13 14//////////////////////////////////// Iphone13Builder.java 15public class Iphone13Builder implements PhoneBuilder{ 16 17 private Phone phone; 18 19 public Iphone13Builder() { 20 this.phone = new Phone(); 21 } 22 23 @Override 24 public void buildName() { 25 phone.setName(\u0026#34;Iphone13\u0026#34;); 26 } 27 28 @Override 29 public void buildRealeseDate() { 30 phone.","title":"GoF의 BuilderPattern"},{"content":"정의 lambda는 Java 8에서 처음으로 등장했다. lambda는 이름이 없는 함수, 익명함수 정도로 이해하면 되겠다. lambda는 변수형태로 저장이 가능하며 따라서 메서드의 인수로 전달이 가능하다. 1import java.util.ArrayList; 2 3public class Main { 4 public static void main(String[] args) { 5 ArrayList\u0026lt;Integer\u0026gt; numbers = new ArrayList\u0026lt;Integer\u0026gt;(); 6 numbers.add(5); 7 numbers.add(9); 8 numbers.add(8); 9 numbers.add(1); 10 // (parameter) -\u0026gt; {code block} 형태로 작성한 예제이다. 11 numbers.forEach( (n) -\u0026gt; { System.out.println(n); } ); 12 13 } 14} Java의 Consumer 인터페이스를 통해서 lambda를 변수에 할당할 수 있다.\n1import java.util.ArrayList; 2import java.util.function.Consumer; 3 4public class Main { 5 public static void main(String[] args) { 6 ArrayList\u0026lt;Integer\u0026gt; numbers = new ArrayList\u0026lt;Integer\u0026gt;(); 7 numbers.add(5); 8 numbers.add(9); 9 numbers.add(8); 10 numbers.add(1); 11 // lambda식을 변수에 할당. 12 Consumer\u0026lt;Integer\u0026gt; method = (n) -\u0026gt; { System.out.println(n); }; 13 numbers.forEach( method ); 14 } 15} 1public class Main { 2 3 4 public static void main(String[] args){ 5 6 User user = new User(); 7 8 // 익명 인터페이스 방식 9 user.setAccountPrinter(new AccountPrinter() { 10 @Override 11 public void printDepositWithUserName(int deposit) { 12 System.out.println(\u0026#34;deposit = \u0026#34; + deposit); 13 } 14 }); 15 16 // 익명인터페이스 17 user.setAccountPrinter(deposit -\u0026gt; System.out.println(\u0026#34;deposit = \u0026#34; + deposit)); 18 19 20 21 } 22 23 24} 25 26 27public class User { 28 29 AccountPrinter accountPrinter; 30 31 public void setAccountPrinter(AccountPrinter accountPrinter){ 32 this.accountPrinter = accountPrinter; 33 } 34 35 36} 37 38public interface AccountPrinter { 39 40 void printDepositWithUserName(int deposit); 41 42} ","permalink":"https://92SooJong.github.io/posts/java/lambda/","summary":"정의 lambda는 Java 8에서 처음으로 등장했다. lambda는 이름이 없는 함수, 익명함수 정도로 이해하면 되겠다. lambda는 변수형태로 저장이 가능하며 따라서 메서드의 인수로 전달이 가능하다. 1import java.util.ArrayList; 2 3public class Main { 4 public static void main(String[] args) { 5 ArrayList\u0026lt;Integer\u0026gt; numbers = new ArrayList\u0026lt;Integer\u0026gt;(); 6 numbers.add(5); 7 numbers.add(9); 8 numbers.add(8); 9 numbers.add(1); 10 // (parameter) -\u0026gt; {code block} 형태로 작성한 예제이다. 11 numbers.forEach( (n) -\u0026gt; { System.out.println(n); } ); 12 13 } 14} Java의 Consumer 인터페이스를 통해서 lambda를 변수에 할당할 수 있다.","title":"Lambda"},{"content":"역할 자바에서는 메모리를 GC라는 알고리즘을 통하여 관리한다. 자바에서 쓰레기는 객체이다. 객체는 메모리를 점유하고 있으며, 필요가 없어진다면 메모리에서 제거되어야 한다. 객체를 사용하는 메소드를 호출해서 특정 작업을 수행한다고 해보자. 메소드가 종료될때 사용했던 객체들은 GC에 의해 메모리에서 제거된다. GC는 객체를 메모리에 할당하는 작업을 수행하며, 메모리중 사용중인 공간과 사용하지 않고 있는 공간을 찾을 수 있다. GC가 더이상 사용하지 않는 공간을 찾을 수 없을때 객체를 메모리에 할당하려고 한다면 OutOfMemoryError이 발생한다. JVM 메모리 구조 JVM의 메모리 구조는 크게 아래 4가지로 나뉜다. 이 중에서 GC는 힙 영역의 메모리만 관리한다. 클래스 스택 힙 네이티브 메소드 힙(Heap) 영역 살펴보기 GC가 관리하는 Heap 영역은 다시 Young, Old, Perm으로 나뉜다. Perm 영역은 Application 단에선 사용하지 않고 JVM을 구동하는데 필요한 정보들을 담기위해 사용된다. Young 영역은 다시 2개의 영역으로 나뉘는데 Eden과 Survivor로 나뉜다. 원리 객체가 생성되면 일단 Eden 영역의 메모리에 올라간다. Eden영역에 어느정도 데이터가 쌓이면, 데이터가 Survivor 영역으로 이동된다. ( 사용하지 않으면 그대로 삭제되기도 함 ) 더이상 Eden과 Survivor 영역에(합쳐서 Young 영역) 공간이 없다면 Old 영역으로 이동하는 방식이다. 참고 https://12bme.tistory.com/57\n","permalink":"https://92SooJong.github.io/posts/java/garbage-collector/","summary":"역할 자바에서는 메모리를 GC라는 알고리즘을 통하여 관리한다. 자바에서 쓰레기는 객체이다. 객체는 메모리를 점유하고 있으며, 필요가 없어진다면 메모리에서 제거되어야 한다. 객체를 사용하는 메소드를 호출해서 특정 작업을 수행한다고 해보자. 메소드가 종료될때 사용했던 객체들은 GC에 의해 메모리에서 제거된다. GC는 객체를 메모리에 할당하는 작업을 수행하며, 메모리중 사용중인 공간과 사용하지 않고 있는 공간을 찾을 수 있다. GC가 더이상 사용하지 않는 공간을 찾을 수 없을때 객체를 메모리에 할당하려고 한다면 OutOfMemoryError이 발생한다. JVM 메모리 구조 JVM의 메모리 구조는 크게 아래 4가지로 나뉜다.","title":"Garbage Collector"},{"content":"도커란? 컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이다. 컨테이너 기반의 오픈소스 가상화 플랫폼이자, 생태계이다. 컨테이너란? 컨테이너 안에는 다양한 프로그램 및 실행환경을 담고있는 상자다. 컨테이너에는 Sysql, Spring 등 각종 환경을 담고 있다. 따라서 AWS, Azure, Google cloud등 어디서든 쉽게 실행이 가능하게 해준다. 컨테이너(도커) 이미지란? 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지이다. 프로그램을 실행하는데 필요한 설정이나 종속성들을 갖고있다. 컨테이너 이미지는 런타임시에 컨테이너가 된다. 이미지의 인스턴스가 컨테이너이다. ","permalink":"https://92SooJong.github.io/posts/docker/basic/","summary":"도커란? 컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이다. 컨테이너 기반의 오픈소스 가상화 플랫폼이자, 생태계이다. 컨테이너란? 컨테이너 안에는 다양한 프로그램 및 실행환경을 담고있는 상자다. 컨테이너에는 Sysql, Spring 등 각종 환경을 담고 있다. 따라서 AWS, Azure, Google cloud등 어디서든 쉽게 실행이 가능하게 해준다. 컨테이너(도커) 이미지란? 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지이다. 프로그램을 실행하는데 필요한 설정이나 종속성들을 갖고있다.","title":"Docker 용어"},{"content":"SQL의 정의 SQL은 \u0026lsquo;구조화 된 쿼리 언어 (Structured Query Language)\u0026lsquo;를 말합니다. SQL은 관계형 DB에 저장된 데이터에 access하기 위해 사용하는 표준 언어. ( SELECT, UPDATE, INSERT 등 ) 일반적으로 우리가 배워왔던 Mysql, Oracle, Mssql 같은 고전적인 데이터베이스를 관계형 데이터베이스라고하며 이들은 모두 SQL을 기반으로 만들어졌다. PL/SQL PL/SQL은 SQL문을 사용하여 프로그램을 작성할 수 있도록 확장해놓은 오라클의 절차적언어 ( DECLARE, EXCEPTION, LOOP등 절차적 프로그래밍 가능 )\nNoSQL 비관계형 Database를 NoSQL이라고 부르며, Not Only SQL(SQL 뿐만이 아닌. 이라는 뜻)의 줄임말이다. 즉, SQL뿐만 아니라 다른 장점을 더 가지고 있다는 뜻. 대표적으로 MongoDB, CouchDB 등이 있다.\n표준문법에 대해 각 SQL은 나름의 문법들이 있지만 미국 국립 표준 협회(American National Standards Institute,ANSI)에서 지정한 SQL 문법이 있다. 이를 ANSI Query라고 부른다. ANSI를 제외하면 Oracle문법이 대중적으로 많이 사용된다.\n","permalink":"https://92SooJong.github.io/posts/database/plsql-and-nosql/","summary":"SQL의 정의 SQL은 \u0026lsquo;구조화 된 쿼리 언어 (Structured Query Language)\u0026lsquo;를 말합니다. SQL은 관계형 DB에 저장된 데이터에 access하기 위해 사용하는 표준 언어. ( SELECT, UPDATE, INSERT 등 ) 일반적으로 우리가 배워왔던 Mysql, Oracle, Mssql 같은 고전적인 데이터베이스를 관계형 데이터베이스라고하며 이들은 모두 SQL을 기반으로 만들어졌다. PL/SQL PL/SQL은 SQL문을 사용하여 프로그램을 작성할 수 있도록 확장해놓은 오라클의 절차적언어 ( DECLARE, EXCEPTION, LOOP등 절차적 프로그래밍 가능 )\nNoSQL 비관계형 Database를 NoSQL이라고 부르며, Not Only SQL(SQL 뿐만이 아닌.","title":"PLSQL과 NoSQL"},{"content":"StringBuilder String 간의 Concat연산을 메모리를 최대한 효율적으로 활용해서 수행하기 위한 객체다. \u0026ldquo;aaa\u0026rdquo; + \u0026ldquo;bbb\u0026quot;를 수행하면 Java는 내부적으로 \u0026ldquo;aaabbbb\u0026quot;를 담기 위해 새로운 메모리공간을 사용한다. StringBuilder는 \u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;bbb\u0026quot;연산을 하면 새로운 메모리 공간을 사용하지 않고 \u0026ldquo;aaa\u0026quot;와 \u0026ldquo;bbb\u0026quot;를 합치게 해준다. 1 2StringBuilder sb = new StringBuilder(); 3 4sb.append(\u0026#34;aaa\u0026#34;); 5sb.append(\u0026#34;bbb\u0026#34;); 6 7System.out.println(sb.toString()); 동기화를 보장하진 않는다. StringBuilder는 MultiThread 환경에서는 사용하지 않는게 좋다. ( Thread가 String Buffer에 동시접근이 가능하다. ) 동기화가 요구된다면 StringBuffer를 사용할 것을 권장한다. StringBuffer StringBuffer는 Multi Thread로부터 안전하다. 쓰레드가 한번에 하나씩만 String Buffer에 접근이 가능하다. StringBuilder와 마찬가지로 append와 insert가 주요 메서드이다. ","permalink":"https://92SooJong.github.io/posts/java/stringbuilder/","summary":"StringBuilder String 간의 Concat연산을 메모리를 최대한 효율적으로 활용해서 수행하기 위한 객체다. \u0026ldquo;aaa\u0026rdquo; + \u0026ldquo;bbb\u0026quot;를 수행하면 Java는 내부적으로 \u0026ldquo;aaabbbb\u0026quot;를 담기 위해 새로운 메모리공간을 사용한다. StringBuilder는 \u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;bbb\u0026quot;연산을 하면 새로운 메모리 공간을 사용하지 않고 \u0026ldquo;aaa\u0026quot;와 \u0026ldquo;bbb\u0026quot;를 합치게 해준다. 1 2StringBuilder sb = new StringBuilder(); 3 4sb.append(\u0026#34;aaa\u0026#34;); 5sb.append(\u0026#34;bbb\u0026#34;); 6 7System.out.println(sb.toString()); 동기화를 보장하진 않는다. StringBuilder는 MultiThread 환경에서는 사용하지 않는게 좋다. ( Thread가 String Buffer에 동시접근이 가능하다. ) 동기화가 요구된다면 StringBuffer를 사용할 것을 권장한다. StringBuffer StringBuffer는 Multi Thread로부터 안전하다.","title":"StringBuilder"},{"content":" 자바의 Thread의 실행순서는 JVM이 결정하는것이 아니라 OS의 Thread 스케쥴러에 의해 결정된다. OS에 의존적인 JVM의 몇가지 사항중 하나다. 쓰레드는 자신만의 Call Stack을 가짐으로써 쓰레드간 독립적인 작업을 수행할 수 있게 된다. start() 함수가 새로운 Call Stack을 생성하는 명령어다. run() 메소드를 직접 호출해선 안된다. Thread에는 사용자 쓰레드와 데몬 쓰레드가 있다. 데몬 쓰레드는 사용자 쓰레드가 수행할 작업을 보조하는 역할을 한다. 프로그램은 사용자 쓰레드가 하나도 없을때 종료된다. sleep 함수는 쓰레드를 sleep 시킬 수 있으며, static 메소드기 때문에 자신에게만 적용된다. A 쓰레드가 B쓰레드를 sleep 시킬수 없다. 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막기위해 동기화 작업을 수행해야한다. 공유되어선 안되는 코드를 묶어서 \u0026ldquo;임계 영역\u0026quot;으로 설정해야한다. 임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입이 가능하다. ( 객체1개에 락이 1개만 존재한다. 메소드가 아닌것에 주의! . 출금과 관련된 예제를 떠올려보자.) 임계영역에는 한개의 쓰레드만 들어갈 수 있기때문에 속도측면의 문제점를 줄이기 위해선 임계영역을 최소화해야한다. wait()과 notify()는 동기화 블럭내에서만 사용할 수 있다. wait()을 만나면 객체에 대한 lock을 풀고 해당위치에서 대기상태가 된다. lock을 가진 Thread는 작업을 완료하고 notify()수행하면 자신의 lock을 wating pool에 있는 쓰레드중 하나에게 전달한다. notifyAll()은 wating pool에 있는 모든 Thread를 꺼낸다. ","permalink":"https://92SooJong.github.io/posts/java/thread/","summary":"자바의 Thread의 실행순서는 JVM이 결정하는것이 아니라 OS의 Thread 스케쥴러에 의해 결정된다. OS에 의존적인 JVM의 몇가지 사항중 하나다. 쓰레드는 자신만의 Call Stack을 가짐으로써 쓰레드간 독립적인 작업을 수행할 수 있게 된다. start() 함수가 새로운 Call Stack을 생성하는 명령어다. run() 메소드를 직접 호출해선 안된다. Thread에는 사용자 쓰레드와 데몬 쓰레드가 있다. 데몬 쓰레드는 사용자 쓰레드가 수행할 작업을 보조하는 역할을 한다. 프로그램은 사용자 쓰레드가 하나도 없을때 종료된다. sleep 함수는 쓰레드를 sleep 시킬 수 있으며, static 메소드기 때문에 자신에게만 적용된다.","title":"Thread"},{"content":"자바 어노테이션에대해 설명한 내용을 번역합니다. 출처 : https://dzone.com/articles/how-annotations-work-java\n어노테이션은 자바에서 중요한 부분입니다. 자바 어노테이션은 J2SE 5.0에서 처음 등장했습니다. 우리가 흔히 마주하는 어노테이션으론 @Override나 @Deprecated같은 것들이 있습니다.\n어노테이션이란 무엇인가? 어노테이션은 메타데이터다. 메타데이터는 데이터에 대한 데이터다.( 특정 데이터 집합을 설명하는 데이터라고 이해하면 쉽다. ) 자바의 어노테이션은 코드를 위한 메타데이터다. 아래의 코드를 보자.\n1@Override 2public String toString() { 3 return \u0026#34;This is String Representation of current object.\u0026#34;; 4} 나는 toString() 메소드를 오버라이드 받았다. 그리고 @Override 어노테이션이 해당 코드의 윗부분에 위치하고 있다. 내가 @Override를 작성하지 않더라도 코드는 에러를 발생시키지 않고 잘 실행된다. 그렇다면 어노테이션을 사용해서 얻는 이점이 무엇일까? @Override는 컴파일러에게 이 메소드가 오버라이드 되었다는걸 알려준다.( 메소드에 대한 메타데이터 역할 ) 이떄 만약 부모 클래스에 toString()이 존재하지 않는다면 컴파일러 에러가 발생하게 된다. ( 오버라이드 되었다고 표시해뒀는데 실제론 오버라이드를 수행하지 않기 떄문에 에러 발생! )\n메소드 toString()을 toStrring()으로 잘못 타이핑한 경우를 보자. 만약 @Override를 사용하지 않는다면 오타를 입력했더라도 코드상 문제는 없기때문에 정상적으로 실행된다. 다만 실행결과가 예상한것과 다를것이다. 하지만 @Override를 메소드에 적용했을때는 컴파일러가 부모클래스에서 toStrring()를 찾을것이고 해당 메소드의 이름을 가진 메소드가 없기 때문에 컴파일 에러를 띄운다. 어노테이션은 클래스,메소드,필드,파라미터,변수,생성자 또는 패키지를 꾸밀수 있게 해주는 자바의 특별한 구성요소다.\n어노테이션의 탄생배경은? 어노테이션이 나타나기 이전에는 XML이 메타데이터를 나타내기 위해 주로 사용되었다. 몇몇 개발자들이 XML의 유지보수에 대한 의문점을 가지게 되었다. 그들은 코드와 너무 느슨하게 결합되어 관리되고 있던 XML보다 코드와 밀접하게 결합되어 관리할수 있는 방법을 원했다. XML 설정(Configuration)은 코드와 설정을 분리해서 관리하기 위해 등장한것이다. 즉, 어노테이션과는 완전히 반대되는 목적을 가지고 태어난 친구다. 그렇다보니 구글에 가면 여전히 XML이냐, annotation이냐를 가지고 많이들 논쟁을 벌이고 있다.\n당신이 어플리케이션 전체에 적용하고 싶은 변수나 파라미터를 선언하고 싶은 경우에는 별도의 소스코드를 작성할 필요가 없는 XML이 어노테이션보단 좋은 선택이 된다.(XML문서에만 작성해두면 애플리케이션 어디서든지 사용이 가능하다.) 그런데 만약 몇몇 메소드만 서비스 로직을 처리하는 메소드로 표시하고 싶은 경우( 예. SpringMVC의 @Service 어노테이션) 어노테이션이 XML보다 더 좋은 선택이 된다. 소스의 메소드에 직접 어노테이션을 표기함으로써 개발자가 해당 메소드의 목적을 파악할 수 있게된다.\n어노테이션은 코드상에서 메타데이터를 나타낼수 있다. 어노테이션 등장 이전에는 개발자들이 각자 자신만의 방식으로 메타데이터를 표기했다. ( 마커용 인터페이스를 만든다던지, 주석을 달던지, 팀원간 약속된 키워드를 하는식으로 말이다. ) 하지만 어노테이션은 표준화되어있기 때문에 정형화된 메타데이터 표시가 가능하다. 최근에는 대부분의 프레임워크들이 XML과 어노테이션을 함께 사용하고 있다. ( 프로젝트 전반에 대한 설정은 XML을 사용하고, Bean등록과 같이 선택적인 작업을 할때는 어노테이션을 사용한다. )\n어노테이션은 어떻게 동작하고, 커스텀 어노테이션은 어떻게 만들까? 어노테이션을 생성하는 방법은 인터페이스와 유사하다. 아래는 자바의 기본 어노테이션인 @Override와 직접 작성한 @Tode 어노테이션이다. 먼저 @Override 어노테이션부터 살펴보자.\n1@Target(ElementType.METHOD) 2@Retention(RetentionPolicy.SOURCE) 3public @interface Override { 4} 뭔가 수상한듯한 생김새를 하고 있다. @Override는 어떤 동작도 수행하지 않는다. 그냥 단지 @Override를 가진 메소드가 부모클래스에 정의되어 있는지 체크만하는 역할을 한다. ( 어노테이션은 단지 메타데이터를 의미할뿐 어떠한 비즈니스로직도 가지고 있지 않다는걸 기억해야한다. ) 어노테이션은 단지 어트리뷰트(클래스/메소드/패키지/필드)에 대한 정보를 제공할 뿐이다. 코드들은 이런 정보를 읽어서 적절한 조치를 취한다.\n@Override는 JVM이 사용하며 바이트코드 레벨에서 @Override에 대한 동작을 수행한다. 따라서 @Override는 개발자가 제어할수도 없고, 커스터마이징할 수도 없다. 따라서 필요한 어노테이션이 있다면 우리가 직접 작성해야한다.\nLet’s understand the key terms used for writing annotations one by one. In the above examples, you will see annotations are used on annotations.\nJ2SE 5.0 provides four annotations in the java.lang.annotation package that are used only when writing annotations:\n@Documented – Javadocs에 해당 어노테이션을 추가할지 말지 결정한다.\n@Retention – 언제 어노테이션이 사용되는지를 나타낸다.(=언제까지 어노테이션을 유지할까 = 어노테이션의 라이프사이클 )\n@Target? – 어노테이션이 어디에 적용될지를 나타낸다. ( 작성하지 않으면 7개의 모든 곳에 다 위치할 수 있다. )\nElementType.TYPE (class, interface, enum) ElementType.FIELD (instance variable) ElementType.METHOD ElementType.PARAMETER ElementType.CONSTRUCTOR ElementType.LOCAL_VARIABLE ElementType.ANNOTATION_TYPE (on another annotation) ElementType.PACKAGE (remember package-info.java) @Inherited – 현재의 어노테이션을 적용할 서브클래스는 무엇인가?\n이제 직접 만든 @Todo 어노테이션을 살펴보자. 내부에 어떤 값들이 정의되어 있다. 어노테이션은 Primitive 타입과 String 그리고 enum을 지원한다. 모든 어트리뷰트는 메소드 형태로 정의되며 default값이 필요하다.\n1@Target(ElementType.METHOD) 2@Retention(RetentionPolicy.RUNTIME) 3@interface Todo { 4 public enum Priority {LOW, MEDIUM, HIGH} 5 public enum Status {STARTED, NOT_STARTED} 6 String author() default \u0026#34;Yash\u0026#34;; 7 Priority priority() default Priority.LOW; 8 Status status() default Status.NOT_STARTED; 9} @Todo 어노테이션은 아래와 같이 사용하면 된다.\n1@Todo(priority = Todo.Priority.MEDIUM, author = \u0026#34;Yashwant\u0026#34;, status = Todo.Status.STARTED) 2public void incompleteMethod1() { 3//Some business logic is written 4//But it’s not complete yet 5} 만약 아래와 같이 어트리뷰트가 하나밖에 없는 @Author 어노테이션을 만들었다면 value=\u0026ldquo;Yashwant\u0026quot;로 작성하지 않고 \u0026ldquo;Yashwant\u0026quot;라고만 작성하면 된다.\n1@interface Author{ 2 String value(); 3} 1@Author(\u0026#34;Yashwant\u0026#34;) 2public void someMethod() { 3} 이제 어노테이션을 사용하기 위한 코드를 작성해보자. 여기서는 자바의 Reflection을 통해 어노테이션을 사용한다. (Reflection 간단설명 : 컴파일 시간(Compile Time)이 아니라 실행 시간(Run Time)에 동적으로 특정 오브젝트의 정보를 추출하거나, 오브젝트를 생성 할 수 있다. ) Reflection은 클래스,메소드,필드 오브젝트를 제공하는데 각 오브젝트들은 모두 getAnnotation()이라는 메소드를 가지고 있다. getAnnotation()메소드는 오브젝트에 적용되어 있는 어노테이션을 반환해준다. BusinessLogic 이라는 클래스에 들어있는 모든 Method를 For loop를 통해서 불러오고, 메소드에 @Todo 어노테이션이 있다면 결과를 출력하도록 한다.\n1Class businessLogicClass = BusinessLogic.class; 2 3for(Method method : businessLogicClass.getMethods()) { 4 Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class); 5 if(todoAnnotation != null) { 6 System.out.println(\u0026#34; Method Name : \u0026#34; + method.getName()); 7 System.out.println(\u0026#34; Author : \u0026#34; + todoAnnotation.author()); 8 System.out.println(\u0026#34; Priority : \u0026#34; + todoAnnotation.priority()); 9 System.out.println(\u0026#34; Status : \u0026#34; + todoAnnotation.status()); 10 } 11} ","permalink":"https://92SooJong.github.io/posts/java/annotation/","summary":"자바 어노테이션에대해 설명한 내용을 번역합니다. 출처 : https://dzone.com/articles/how-annotations-work-java\n어노테이션은 자바에서 중요한 부분입니다. 자바 어노테이션은 J2SE 5.0에서 처음 등장했습니다. 우리가 흔히 마주하는 어노테이션으론 @Override나 @Deprecated같은 것들이 있습니다.\n어노테이션이란 무엇인가? 어노테이션은 메타데이터다. 메타데이터는 데이터에 대한 데이터다.( 특정 데이터 집합을 설명하는 데이터라고 이해하면 쉽다. ) 자바의 어노테이션은 코드를 위한 메타데이터다. 아래의 코드를 보자.\n1@Override 2public String toString() { 3 return \u0026#34;This is String Representation of current object.\u0026#34;; 4} 나는 toString() 메소드를 오버라이드 받았다. 그리고 @Override 어노테이션이 해당 코드의 윗부분에 위치하고 있다.","title":"Annotation"},{"content":"JavaBean은 단지 클래스 작성 규약일뿐이다.\nAll properties are private (use getters/setters)\nA public no-argument constructor\nImplements Serializable.\nhttps://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly\njava.bean 패키지 설명 링크\nhttps://www.geeksforgeeks.org/pojo-vs-java-beans/\n","permalink":"https://92SooJong.github.io/posts/java/javabeans/","summary":"JavaBean은 단지 클래스 작성 규약일뿐이다.\nAll properties are private (use getters/setters)\nA public no-argument constructor\nImplements Serializable.\nhttps://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly\njava.bean 패키지 설명 링크\nhttps://www.geeksforgeeks.org/pojo-vs-java-beans/","title":"Java Beans"}]